// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"strconv"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/dictyBase/go-genproto/dictybaseapis/publication"
	"github.com/dictyBase/go-genproto/dictybaseapis/stock"
	"github.com/dictyBase/go-genproto/dictybaseapis/user"
	"github.com/dictyBase/graphql-server/internal/graphql/models"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Author() AuthorResolver
	Mutation() MutationResolver
	Permission() PermissionResolver
	Plasmid() PlasmidResolver
	Publication() PublicationResolver
	Query() QueryResolver
	Role() RoleResolver
	Strain() StrainResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Author struct {
		LastName  func(childComplexity int) int
		FirstName func(childComplexity int) int
		Initials  func(childComplexity int) int
		Rank      func(childComplexity int) int
	}

	DeletePermission struct {
		Success func(childComplexity int) int
	}

	DeleteRole struct {
		Success func(childComplexity int) int
	}

	DeleteStock struct {
		Success func(childComplexity int) int
	}

	DeleteUser struct {
		Success func(childComplexity int) int
	}

	Mutation struct {
		CreateStrain                     func(childComplexity int, input *models.CreateStrainInput) int
		CreatePlasmid                    func(childComplexity int, input *models.CreatePlasmidInput) int
		UpdateStrain                     func(childComplexity int, id string, input *models.UpdateStrainInput) int
		UpdatePlasmid                    func(childComplexity int, id string, input *models.UpdatePlasmidInput) int
		DeleteStock                      func(childComplexity int, id string) int
		CreateUser                       func(childComplexity int, input *models.CreateUserInput) int
		CreateUserRoleRelationship       func(childComplexity int, userId string, roleId string) int
		UpdateUser                       func(childComplexity int, id string, input *models.UpdateUserInput) int
		DeleteUser                       func(childComplexity int, id string) int
		CreateRole                       func(childComplexity int, input *models.CreateRoleInput) int
		CreateRolePermissionRelationship func(childComplexity int, roleId string, permissionId string) int
		UpdateRole                       func(childComplexity int, id string, input *models.UpdateRoleInput) int
		DeleteRole                       func(childComplexity int, id string) int
		CreatePermission                 func(childComplexity int, input *models.CreatePermissionInput) int
		UpdatePermission                 func(childComplexity int, id string, input *models.UpdatePermissionInput) int
		DeletePermission                 func(childComplexity int, id string) int
	}

	Permission struct {
		Id          func(childComplexity int) int
		Permission  func(childComplexity int) int
		Description func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Resource    func(childComplexity int) int
	}

	Phenotype struct {
		Phenotype    func(childComplexity int) int
		Notes        func(childComplexity int) int
		Dbxrefs      func(childComplexity int) int
		Publications func(childComplexity int) int
	}

	Plasmid struct {
		Id               func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		CreatedBy        func(childComplexity int) int
		UpdatedBy        func(childComplexity int) int
		Summary          func(childComplexity int) int
		EditableSummary  func(childComplexity int) int
		Depositor        func(childComplexity int) int
		Genes            func(childComplexity int) int
		Dbxrefs          func(childComplexity int) int
		Publications     func(childComplexity int) int
		ImageMap         func(childComplexity int) int
		Sequence         func(childComplexity int) int
		InStock          func(childComplexity int) int
		Keywords         func(childComplexity int) int
		GenbankAccession func(childComplexity int) int
	}

	PlasmidListWithCursor struct {
		Plasmids       func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		Limit          func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	Publication struct {
		Id       func(childComplexity int) int
		Doi      func(childComplexity int) int
		Title    func(childComplexity int) int
		Abstract func(childComplexity int) int
		Journal  func(childComplexity int) int
		PubDate  func(childComplexity int) int
		Volume   func(childComplexity int) int
		Pages    func(childComplexity int) int
		Issn     func(childComplexity int) int
		PubType  func(childComplexity int) int
		Source   func(childComplexity int) int
		Issue    func(childComplexity int) int
		Status   func(childComplexity int) int
		Authors  func(childComplexity int) int
	}

	Query struct {
		Publication     func(childComplexity int, id string) int
		Plasmid         func(childComplexity int, id string) int
		Strain          func(childComplexity int, id string) int
		ListStrains     func(childComplexity int, input *models.ListStockInput) int
		ListPlasmids    func(childComplexity int, input *models.ListStockInput) int
		User            func(childComplexity int, id string) int
		UserByEmail     func(childComplexity int, email string) int
		ListUsers       func(childComplexity int, pagenum string, pagesize string, filter string) int
		Role            func(childComplexity int, id string) int
		ListRoles       func(childComplexity int) int
		Permission      func(childComplexity int, id string) int
		ListPermissions func(childComplexity int) int
	}

	Role struct {
		Id          func(childComplexity int) int
		Role        func(childComplexity int) int
		Description func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Permissions func(childComplexity int) int
	}

	Strain struct {
		Id                  func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		CreatedBy           func(childComplexity int) int
		UpdatedBy           func(childComplexity int) int
		Summary             func(childComplexity int) int
		EditableSummary     func(childComplexity int) int
		Depositor           func(childComplexity int) int
		Genes               func(childComplexity int) int
		Dbxrefs             func(childComplexity int) int
		Publications        func(childComplexity int) int
		SystematicName      func(childComplexity int) int
		Descriptor          func(childComplexity int) int
		Species             func(childComplexity int) int
		Plasmid             func(childComplexity int) int
		Parent              func(childComplexity int) int
		Names               func(childComplexity int) int
		InStock             func(childComplexity int) int
		Phenotypes          func(childComplexity int) int
		GeneticModification func(childComplexity int) int
		MutagenesisMethod   func(childComplexity int) int
		Characteristics     func(childComplexity int) int
		Genotypes           func(childComplexity int) int
	}

	StrainListWithCursor struct {
		Strains        func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		Limit          func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	User struct {
		Id            func(childComplexity int) int
		FirstName     func(childComplexity int) int
		LastName      func(childComplexity int) int
		Email         func(childComplexity int) int
		Organization  func(childComplexity int) int
		GroupName     func(childComplexity int) int
		FirstAddress  func(childComplexity int) int
		SecondAddress func(childComplexity int) int
		City          func(childComplexity int) int
		State         func(childComplexity int) int
		Zipcode       func(childComplexity int) int
		Country       func(childComplexity int) int
		Phone         func(childComplexity int) int
		IsActive      func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Roles         func(childComplexity int) int
	}

	UserList struct {
		Users      func(childComplexity int) int
		PageNum    func(childComplexity int) int
		PageSize   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}
}

type AuthorResolver interface {
	Rank(ctx context.Context, obj *publication.Author) (*string, error)
}
type MutationResolver interface {
	CreateStrain(ctx context.Context, input *models.CreateStrainInput) (*stock.Stock, error)
	CreatePlasmid(ctx context.Context, input *models.CreatePlasmidInput) (*stock.Stock, error)
	UpdateStrain(ctx context.Context, id string, input *models.UpdateStrainInput) (*stock.Stock, error)
	UpdatePlasmid(ctx context.Context, id string, input *models.UpdatePlasmidInput) (*stock.Stock, error)
	DeleteStock(ctx context.Context, id string) (*models.DeleteStock, error)
	CreateUser(ctx context.Context, input *models.CreateUserInput) (*user.User, error)
	CreateUserRoleRelationship(ctx context.Context, userId string, roleId string) (*user.User, error)
	UpdateUser(ctx context.Context, id string, input *models.UpdateUserInput) (*user.User, error)
	DeleteUser(ctx context.Context, id string) (*models.DeleteUser, error)
	CreateRole(ctx context.Context, input *models.CreateRoleInput) (*user.Role, error)
	CreateRolePermissionRelationship(ctx context.Context, roleId string, permissionId string) (*user.Role, error)
	UpdateRole(ctx context.Context, id string, input *models.UpdateRoleInput) (*user.Role, error)
	DeleteRole(ctx context.Context, id string) (*models.DeleteRole, error)
	CreatePermission(ctx context.Context, input *models.CreatePermissionInput) (*user.Permission, error)
	UpdatePermission(ctx context.Context, id string, input *models.UpdatePermissionInput) (*user.Permission, error)
	DeletePermission(ctx context.Context, id string) (*models.DeletePermission, error)
}
type PermissionResolver interface {
	ID(ctx context.Context, obj *user.Permission) (string, error)
	Permission(ctx context.Context, obj *user.Permission) (string, error)
	Description(ctx context.Context, obj *user.Permission) (string, error)
	CreatedAt(ctx context.Context, obj *user.Permission) (time.Time, error)
	UpdatedAt(ctx context.Context, obj *user.Permission) (time.Time, error)
	Resource(ctx context.Context, obj *user.Permission) (*string, error)
}
type PlasmidResolver interface {
	ID(ctx context.Context, obj *stock.Stock) (string, error)
	CreatedAt(ctx context.Context, obj *stock.Stock) (time.Time, error)
	UpdatedAt(ctx context.Context, obj *stock.Stock) (time.Time, error)
	CreatedBy(ctx context.Context, obj *stock.Stock) (user.User, error)
	UpdatedBy(ctx context.Context, obj *stock.Stock) (user.User, error)
	Summary(ctx context.Context, obj *stock.Stock) (*string, error)
	EditableSummary(ctx context.Context, obj *stock.Stock) (*string, error)
	Depositor(ctx context.Context, obj *stock.Stock) (string, error)
	Genes(ctx context.Context, obj *stock.Stock) ([]*string, error)
	Dbxrefs(ctx context.Context, obj *stock.Stock) ([]*string, error)
	Publications(ctx context.Context, obj *stock.Stock) ([]*publication.Publication, error)
	ImageMap(ctx context.Context, obj *stock.Stock) (*string, error)
	Sequence(ctx context.Context, obj *stock.Stock) (*string, error)
	InStock(ctx context.Context, obj *stock.Stock) (bool, error)
	Keywords(ctx context.Context, obj *stock.Stock) ([]*string, error)
	GenbankAccession(ctx context.Context, obj *stock.Stock) (*string, error)
}
type PublicationResolver interface {
	ID(ctx context.Context, obj *publication.Publication) (string, error)
	Doi(ctx context.Context, obj *publication.Publication) (*string, error)
	Title(ctx context.Context, obj *publication.Publication) (*string, error)
	Abstract(ctx context.Context, obj *publication.Publication) (*string, error)
	Journal(ctx context.Context, obj *publication.Publication) (*string, error)
	PubDate(ctx context.Context, obj *publication.Publication) (*time.Time, error)
	Volume(ctx context.Context, obj *publication.Publication) (*string, error)
	Pages(ctx context.Context, obj *publication.Publication) (*string, error)
	Issn(ctx context.Context, obj *publication.Publication) (*string, error)
	PubType(ctx context.Context, obj *publication.Publication) (*string, error)
	Source(ctx context.Context, obj *publication.Publication) (*string, error)
	Issue(ctx context.Context, obj *publication.Publication) (*string, error)
	Status(ctx context.Context, obj *publication.Publication) (*string, error)
	Authors(ctx context.Context, obj *publication.Publication) ([]*publication.Author, error)
}
type QueryResolver interface {
	Publication(ctx context.Context, id string) (*publication.Publication, error)
	Plasmid(ctx context.Context, id string) (*stock.Stock, error)
	Strain(ctx context.Context, id string) (*stock.Stock, error)
	ListStrains(ctx context.Context, input *models.ListStockInput) (*models.StrainListWithCursor, error)
	ListPlasmids(ctx context.Context, input *models.ListStockInput) (*models.PlasmidListWithCursor, error)
	User(ctx context.Context, id string) (*user.User, error)
	UserByEmail(ctx context.Context, email string) (*user.User, error)
	ListUsers(ctx context.Context, pagenum string, pagesize string, filter string) (*models.UserList, error)
	Role(ctx context.Context, id string) (*user.Role, error)
	ListRoles(ctx context.Context) ([]user.Role, error)
	Permission(ctx context.Context, id string) (*user.Permission, error)
	ListPermissions(ctx context.Context) ([]user.Permission, error)
}
type RoleResolver interface {
	ID(ctx context.Context, obj *user.Role) (string, error)
	Role(ctx context.Context, obj *user.Role) (string, error)
	Description(ctx context.Context, obj *user.Role) (string, error)
	CreatedAt(ctx context.Context, obj *user.Role) (time.Time, error)
	UpdatedAt(ctx context.Context, obj *user.Role) (time.Time, error)
	Permissions(ctx context.Context, obj *user.Role) ([]user.Permission, error)
}
type StrainResolver interface {
	ID(ctx context.Context, obj *stock.Stock) (string, error)
	CreatedAt(ctx context.Context, obj *stock.Stock) (time.Time, error)
	UpdatedAt(ctx context.Context, obj *stock.Stock) (time.Time, error)
	CreatedBy(ctx context.Context, obj *stock.Stock) (user.User, error)
	UpdatedBy(ctx context.Context, obj *stock.Stock) (user.User, error)
	Summary(ctx context.Context, obj *stock.Stock) (*string, error)
	EditableSummary(ctx context.Context, obj *stock.Stock) (*string, error)
	Depositor(ctx context.Context, obj *stock.Stock) (string, error)
	Genes(ctx context.Context, obj *stock.Stock) ([]*string, error)
	Dbxrefs(ctx context.Context, obj *stock.Stock) ([]*string, error)
	Publications(ctx context.Context, obj *stock.Stock) ([]*publication.Publication, error)
	SystematicName(ctx context.Context, obj *stock.Stock) (string, error)
	Descriptor(ctx context.Context, obj *stock.Stock) (string, error)
	Species(ctx context.Context, obj *stock.Stock) (string, error)
	Plasmid(ctx context.Context, obj *stock.Stock) (*string, error)
	Parent(ctx context.Context, obj *stock.Stock) (*stock.Stock, error)
	Names(ctx context.Context, obj *stock.Stock) ([]*string, error)
	InStock(ctx context.Context, obj *stock.Stock) (bool, error)
	Phenotypes(ctx context.Context, obj *stock.Stock) ([]*models.Phenotype, error)
	GeneticModification(ctx context.Context, obj *stock.Stock) (*string, error)
	MutagenesisMethod(ctx context.Context, obj *stock.Stock) (*string, error)
	Characteristics(ctx context.Context, obj *stock.Stock) ([]*string, error)
	Genotypes(ctx context.Context, obj *stock.Stock) ([]*string, error)
}
type UserResolver interface {
	ID(ctx context.Context, obj *user.User) (string, error)
	FirstName(ctx context.Context, obj *user.User) (string, error)
	LastName(ctx context.Context, obj *user.User) (string, error)
	Email(ctx context.Context, obj *user.User) (string, error)
	Organization(ctx context.Context, obj *user.User) (*string, error)
	GroupName(ctx context.Context, obj *user.User) (*string, error)
	FirstAddress(ctx context.Context, obj *user.User) (*string, error)
	SecondAddress(ctx context.Context, obj *user.User) (*string, error)
	City(ctx context.Context, obj *user.User) (*string, error)
	State(ctx context.Context, obj *user.User) (*string, error)
	Zipcode(ctx context.Context, obj *user.User) (*string, error)
	Country(ctx context.Context, obj *user.User) (*string, error)
	Phone(ctx context.Context, obj *user.User) (*string, error)
	IsActive(ctx context.Context, obj *user.User) (bool, error)
	CreatedAt(ctx context.Context, obj *user.User) (time.Time, error)
	UpdatedAt(ctx context.Context, obj *user.User) (time.Time, error)
	Roles(ctx context.Context, obj *user.User) ([]user.Role, error)
}

func field_Mutation_createStrain_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.CreateStrainInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.CreateStrainInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateStrainInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_createPlasmid_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.CreatePlasmidInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.CreatePlasmidInput
		if tmp != nil {
			ptr1, err = UnmarshalCreatePlasmidInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updateStrain_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *models.UpdateStrainInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.UpdateStrainInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdateStrainInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_updatePlasmid_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *models.UpdatePlasmidInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.UpdatePlasmidInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdatePlasmidInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deleteStock_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Mutation_createUser_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.CreateUserInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateUserInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_createUserRoleRelationship_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["roleId"]; ok {
		var err error
		arg1, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roleId"] = arg1
	return args, nil

}

func field_Mutation_updateUser_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *models.UpdateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.UpdateUserInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdateUserInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deleteUser_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Mutation_createRole_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.CreateRoleInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.CreateRoleInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateRoleInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_createRolePermissionRelationship_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["roleId"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roleId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["permissionId"]; ok {
		var err error
		arg1, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["permissionId"] = arg1
	return args, nil

}

func field_Mutation_updateRole_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *models.UpdateRoleInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.UpdateRoleInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdateRoleInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deleteRole_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Mutation_createPermission_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.CreatePermissionInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.CreatePermissionInput
		if tmp != nil {
			ptr1, err = UnmarshalCreatePermissionInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updatePermission_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *models.UpdatePermissionInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.UpdatePermissionInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdatePermissionInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deletePermission_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_publication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_plasmid_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_strain_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_listStrains_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.ListStockInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.ListStockInput
		if tmp != nil {
			ptr1, err = UnmarshalListStockInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Query_listPlasmids_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *models.ListStockInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 models.ListStockInput
		if tmp != nil {
			ptr1, err = UnmarshalListStockInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Query_user_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_userByEmail_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["email"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg0
	return args, nil

}

func field_Query_listUsers_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["pagenum"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagenum"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["pagesize"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pagesize"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg2
	return args, nil

}

func field_Query_role_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_permission_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "Author.last_name":
		if e.complexity.Author.LastName == nil {
			break
		}

		return e.complexity.Author.LastName(childComplexity), true

	case "Author.first_name":
		if e.complexity.Author.FirstName == nil {
			break
		}

		return e.complexity.Author.FirstName(childComplexity), true

	case "Author.initials":
		if e.complexity.Author.Initials == nil {
			break
		}

		return e.complexity.Author.Initials(childComplexity), true

	case "Author.rank":
		if e.complexity.Author.Rank == nil {
			break
		}

		return e.complexity.Author.Rank(childComplexity), true

	case "DeletePermission.success":
		if e.complexity.DeletePermission.Success == nil {
			break
		}

		return e.complexity.DeletePermission.Success(childComplexity), true

	case "DeleteRole.success":
		if e.complexity.DeleteRole.Success == nil {
			break
		}

		return e.complexity.DeleteRole.Success(childComplexity), true

	case "DeleteStock.success":
		if e.complexity.DeleteStock.Success == nil {
			break
		}

		return e.complexity.DeleteStock.Success(childComplexity), true

	case "DeleteUser.success":
		if e.complexity.DeleteUser.Success == nil {
			break
		}

		return e.complexity.DeleteUser.Success(childComplexity), true

	case "Mutation.createStrain":
		if e.complexity.Mutation.CreateStrain == nil {
			break
		}

		args, err := field_Mutation_createStrain_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateStrain(childComplexity, args["input"].(*models.CreateStrainInput)), true

	case "Mutation.createPlasmid":
		if e.complexity.Mutation.CreatePlasmid == nil {
			break
		}

		args, err := field_Mutation_createPlasmid_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePlasmid(childComplexity, args["input"].(*models.CreatePlasmidInput)), true

	case "Mutation.updateStrain":
		if e.complexity.Mutation.UpdateStrain == nil {
			break
		}

		args, err := field_Mutation_updateStrain_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateStrain(childComplexity, args["id"].(string), args["input"].(*models.UpdateStrainInput)), true

	case "Mutation.updatePlasmid":
		if e.complexity.Mutation.UpdatePlasmid == nil {
			break
		}

		args, err := field_Mutation_updatePlasmid_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePlasmid(childComplexity, args["id"].(string), args["input"].(*models.UpdatePlasmidInput)), true

	case "Mutation.deleteStock":
		if e.complexity.Mutation.DeleteStock == nil {
			break
		}

		args, err := field_Mutation_deleteStock_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteStock(childComplexity, args["id"].(string)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := field_Mutation_createUser_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(*models.CreateUserInput)), true

	case "Mutation.createUserRoleRelationship":
		if e.complexity.Mutation.CreateUserRoleRelationship == nil {
			break
		}

		args, err := field_Mutation_createUserRoleRelationship_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUserRoleRelationship(childComplexity, args["userId"].(string), args["roleId"].(string)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := field_Mutation_updateUser_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(string), args["input"].(*models.UpdateUserInput)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := field_Mutation_deleteUser_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(string)), true

	case "Mutation.createRole":
		if e.complexity.Mutation.CreateRole == nil {
			break
		}

		args, err := field_Mutation_createRole_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRole(childComplexity, args["input"].(*models.CreateRoleInput)), true

	case "Mutation.createRolePermissionRelationship":
		if e.complexity.Mutation.CreateRolePermissionRelationship == nil {
			break
		}

		args, err := field_Mutation_createRolePermissionRelationship_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRolePermissionRelationship(childComplexity, args["roleId"].(string), args["permissionId"].(string)), true

	case "Mutation.updateRole":
		if e.complexity.Mutation.UpdateRole == nil {
			break
		}

		args, err := field_Mutation_updateRole_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRole(childComplexity, args["id"].(string), args["input"].(*models.UpdateRoleInput)), true

	case "Mutation.deleteRole":
		if e.complexity.Mutation.DeleteRole == nil {
			break
		}

		args, err := field_Mutation_deleteRole_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRole(childComplexity, args["id"].(string)), true

	case "Mutation.createPermission":
		if e.complexity.Mutation.CreatePermission == nil {
			break
		}

		args, err := field_Mutation_createPermission_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePermission(childComplexity, args["input"].(*models.CreatePermissionInput)), true

	case "Mutation.updatePermission":
		if e.complexity.Mutation.UpdatePermission == nil {
			break
		}

		args, err := field_Mutation_updatePermission_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePermission(childComplexity, args["id"].(string), args["input"].(*models.UpdatePermissionInput)), true

	case "Mutation.deletePermission":
		if e.complexity.Mutation.DeletePermission == nil {
			break
		}

		args, err := field_Mutation_deletePermission_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePermission(childComplexity, args["id"].(string)), true

	case "Permission.id":
		if e.complexity.Permission.Id == nil {
			break
		}

		return e.complexity.Permission.Id(childComplexity), true

	case "Permission.permission":
		if e.complexity.Permission.Permission == nil {
			break
		}

		return e.complexity.Permission.Permission(childComplexity), true

	case "Permission.description":
		if e.complexity.Permission.Description == nil {
			break
		}

		return e.complexity.Permission.Description(childComplexity), true

	case "Permission.created_at":
		if e.complexity.Permission.CreatedAt == nil {
			break
		}

		return e.complexity.Permission.CreatedAt(childComplexity), true

	case "Permission.updated_at":
		if e.complexity.Permission.UpdatedAt == nil {
			break
		}

		return e.complexity.Permission.UpdatedAt(childComplexity), true

	case "Permission.resource":
		if e.complexity.Permission.Resource == nil {
			break
		}

		return e.complexity.Permission.Resource(childComplexity), true

	case "Phenotype.phenotype":
		if e.complexity.Phenotype.Phenotype == nil {
			break
		}

		return e.complexity.Phenotype.Phenotype(childComplexity), true

	case "Phenotype.notes":
		if e.complexity.Phenotype.Notes == nil {
			break
		}

		return e.complexity.Phenotype.Notes(childComplexity), true

	case "Phenotype.dbxrefs":
		if e.complexity.Phenotype.Dbxrefs == nil {
			break
		}

		return e.complexity.Phenotype.Dbxrefs(childComplexity), true

	case "Phenotype.publications":
		if e.complexity.Phenotype.Publications == nil {
			break
		}

		return e.complexity.Phenotype.Publications(childComplexity), true

	case "Plasmid.id":
		if e.complexity.Plasmid.Id == nil {
			break
		}

		return e.complexity.Plasmid.Id(childComplexity), true

	case "Plasmid.created_at":
		if e.complexity.Plasmid.CreatedAt == nil {
			break
		}

		return e.complexity.Plasmid.CreatedAt(childComplexity), true

	case "Plasmid.updated_at":
		if e.complexity.Plasmid.UpdatedAt == nil {
			break
		}

		return e.complexity.Plasmid.UpdatedAt(childComplexity), true

	case "Plasmid.created_by":
		if e.complexity.Plasmid.CreatedBy == nil {
			break
		}

		return e.complexity.Plasmid.CreatedBy(childComplexity), true

	case "Plasmid.updated_by":
		if e.complexity.Plasmid.UpdatedBy == nil {
			break
		}

		return e.complexity.Plasmid.UpdatedBy(childComplexity), true

	case "Plasmid.summary":
		if e.complexity.Plasmid.Summary == nil {
			break
		}

		return e.complexity.Plasmid.Summary(childComplexity), true

	case "Plasmid.editable_summary":
		if e.complexity.Plasmid.EditableSummary == nil {
			break
		}

		return e.complexity.Plasmid.EditableSummary(childComplexity), true

	case "Plasmid.depositor":
		if e.complexity.Plasmid.Depositor == nil {
			break
		}

		return e.complexity.Plasmid.Depositor(childComplexity), true

	case "Plasmid.genes":
		if e.complexity.Plasmid.Genes == nil {
			break
		}

		return e.complexity.Plasmid.Genes(childComplexity), true

	case "Plasmid.dbxrefs":
		if e.complexity.Plasmid.Dbxrefs == nil {
			break
		}

		return e.complexity.Plasmid.Dbxrefs(childComplexity), true

	case "Plasmid.publications":
		if e.complexity.Plasmid.Publications == nil {
			break
		}

		return e.complexity.Plasmid.Publications(childComplexity), true

	case "Plasmid.image_map":
		if e.complexity.Plasmid.ImageMap == nil {
			break
		}

		return e.complexity.Plasmid.ImageMap(childComplexity), true

	case "Plasmid.sequence":
		if e.complexity.Plasmid.Sequence == nil {
			break
		}

		return e.complexity.Plasmid.Sequence(childComplexity), true

	case "Plasmid.in_stock":
		if e.complexity.Plasmid.InStock == nil {
			break
		}

		return e.complexity.Plasmid.InStock(childComplexity), true

	case "Plasmid.keywords":
		if e.complexity.Plasmid.Keywords == nil {
			break
		}

		return e.complexity.Plasmid.Keywords(childComplexity), true

	case "Plasmid.genbank_accession":
		if e.complexity.Plasmid.GenbankAccession == nil {
			break
		}

		return e.complexity.Plasmid.GenbankAccession(childComplexity), true

	case "PlasmidListWithCursor.plasmids":
		if e.complexity.PlasmidListWithCursor.Plasmids == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.Plasmids(childComplexity), true

	case "PlasmidListWithCursor.nextCursor":
		if e.complexity.PlasmidListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.NextCursor(childComplexity), true

	case "PlasmidListWithCursor.previousCursor":
		if e.complexity.PlasmidListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.PreviousCursor(childComplexity), true

	case "PlasmidListWithCursor.limit":
		if e.complexity.PlasmidListWithCursor.Limit == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.Limit(childComplexity), true

	case "PlasmidListWithCursor.totalCount":
		if e.complexity.PlasmidListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.TotalCount(childComplexity), true

	case "Publication.id":
		if e.complexity.Publication.Id == nil {
			break
		}

		return e.complexity.Publication.Id(childComplexity), true

	case "Publication.doi":
		if e.complexity.Publication.Doi == nil {
			break
		}

		return e.complexity.Publication.Doi(childComplexity), true

	case "Publication.title":
		if e.complexity.Publication.Title == nil {
			break
		}

		return e.complexity.Publication.Title(childComplexity), true

	case "Publication.abstract":
		if e.complexity.Publication.Abstract == nil {
			break
		}

		return e.complexity.Publication.Abstract(childComplexity), true

	case "Publication.journal":
		if e.complexity.Publication.Journal == nil {
			break
		}

		return e.complexity.Publication.Journal(childComplexity), true

	case "Publication.pub_date":
		if e.complexity.Publication.PubDate == nil {
			break
		}

		return e.complexity.Publication.PubDate(childComplexity), true

	case "Publication.volume":
		if e.complexity.Publication.Volume == nil {
			break
		}

		return e.complexity.Publication.Volume(childComplexity), true

	case "Publication.pages":
		if e.complexity.Publication.Pages == nil {
			break
		}

		return e.complexity.Publication.Pages(childComplexity), true

	case "Publication.issn":
		if e.complexity.Publication.Issn == nil {
			break
		}

		return e.complexity.Publication.Issn(childComplexity), true

	case "Publication.pub_type":
		if e.complexity.Publication.PubType == nil {
			break
		}

		return e.complexity.Publication.PubType(childComplexity), true

	case "Publication.source":
		if e.complexity.Publication.Source == nil {
			break
		}

		return e.complexity.Publication.Source(childComplexity), true

	case "Publication.issue":
		if e.complexity.Publication.Issue == nil {
			break
		}

		return e.complexity.Publication.Issue(childComplexity), true

	case "Publication.status":
		if e.complexity.Publication.Status == nil {
			break
		}

		return e.complexity.Publication.Status(childComplexity), true

	case "Publication.authors":
		if e.complexity.Publication.Authors == nil {
			break
		}

		return e.complexity.Publication.Authors(childComplexity), true

	case "Query.publication":
		if e.complexity.Query.Publication == nil {
			break
		}

		args, err := field_Query_publication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Publication(childComplexity, args["id"].(string)), true

	case "Query.plasmid":
		if e.complexity.Query.Plasmid == nil {
			break
		}

		args, err := field_Query_plasmid_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Plasmid(childComplexity, args["id"].(string)), true

	case "Query.strain":
		if e.complexity.Query.Strain == nil {
			break
		}

		args, err := field_Query_strain_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Strain(childComplexity, args["id"].(string)), true

	case "Query.listStrains":
		if e.complexity.Query.ListStrains == nil {
			break
		}

		args, err := field_Query_listStrains_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListStrains(childComplexity, args["input"].(*models.ListStockInput)), true

	case "Query.listPlasmids":
		if e.complexity.Query.ListPlasmids == nil {
			break
		}

		args, err := field_Query_listPlasmids_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPlasmids(childComplexity, args["input"].(*models.ListStockInput)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := field_Query_user_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(string)), true

	case "Query.userByEmail":
		if e.complexity.Query.UserByEmail == nil {
			break
		}

		args, err := field_Query_userByEmail_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByEmail(childComplexity, args["email"].(string)), true

	case "Query.listUsers":
		if e.complexity.Query.ListUsers == nil {
			break
		}

		args, err := field_Query_listUsers_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListUsers(childComplexity, args["pagenum"].(string), args["pagesize"].(string), args["filter"].(string)), true

	case "Query.role":
		if e.complexity.Query.Role == nil {
			break
		}

		args, err := field_Query_role_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Role(childComplexity, args["id"].(string)), true

	case "Query.listRoles":
		if e.complexity.Query.ListRoles == nil {
			break
		}

		return e.complexity.Query.ListRoles(childComplexity), true

	case "Query.permission":
		if e.complexity.Query.Permission == nil {
			break
		}

		args, err := field_Query_permission_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Permission(childComplexity, args["id"].(string)), true

	case "Query.listPermissions":
		if e.complexity.Query.ListPermissions == nil {
			break
		}

		return e.complexity.Query.ListPermissions(childComplexity), true

	case "Role.id":
		if e.complexity.Role.Id == nil {
			break
		}

		return e.complexity.Role.Id(childComplexity), true

	case "Role.role":
		if e.complexity.Role.Role == nil {
			break
		}

		return e.complexity.Role.Role(childComplexity), true

	case "Role.description":
		if e.complexity.Role.Description == nil {
			break
		}

		return e.complexity.Role.Description(childComplexity), true

	case "Role.created_at":
		if e.complexity.Role.CreatedAt == nil {
			break
		}

		return e.complexity.Role.CreatedAt(childComplexity), true

	case "Role.updated_at":
		if e.complexity.Role.UpdatedAt == nil {
			break
		}

		return e.complexity.Role.UpdatedAt(childComplexity), true

	case "Role.permissions":
		if e.complexity.Role.Permissions == nil {
			break
		}

		return e.complexity.Role.Permissions(childComplexity), true

	case "Strain.id":
		if e.complexity.Strain.Id == nil {
			break
		}

		return e.complexity.Strain.Id(childComplexity), true

	case "Strain.created_at":
		if e.complexity.Strain.CreatedAt == nil {
			break
		}

		return e.complexity.Strain.CreatedAt(childComplexity), true

	case "Strain.updated_at":
		if e.complexity.Strain.UpdatedAt == nil {
			break
		}

		return e.complexity.Strain.UpdatedAt(childComplexity), true

	case "Strain.created_by":
		if e.complexity.Strain.CreatedBy == nil {
			break
		}

		return e.complexity.Strain.CreatedBy(childComplexity), true

	case "Strain.updated_by":
		if e.complexity.Strain.UpdatedBy == nil {
			break
		}

		return e.complexity.Strain.UpdatedBy(childComplexity), true

	case "Strain.summary":
		if e.complexity.Strain.Summary == nil {
			break
		}

		return e.complexity.Strain.Summary(childComplexity), true

	case "Strain.editable_summary":
		if e.complexity.Strain.EditableSummary == nil {
			break
		}

		return e.complexity.Strain.EditableSummary(childComplexity), true

	case "Strain.depositor":
		if e.complexity.Strain.Depositor == nil {
			break
		}

		return e.complexity.Strain.Depositor(childComplexity), true

	case "Strain.genes":
		if e.complexity.Strain.Genes == nil {
			break
		}

		return e.complexity.Strain.Genes(childComplexity), true

	case "Strain.dbxrefs":
		if e.complexity.Strain.Dbxrefs == nil {
			break
		}

		return e.complexity.Strain.Dbxrefs(childComplexity), true

	case "Strain.publications":
		if e.complexity.Strain.Publications == nil {
			break
		}

		return e.complexity.Strain.Publications(childComplexity), true

	case "Strain.systematic_name":
		if e.complexity.Strain.SystematicName == nil {
			break
		}

		return e.complexity.Strain.SystematicName(childComplexity), true

	case "Strain.descriptor":
		if e.complexity.Strain.Descriptor == nil {
			break
		}

		return e.complexity.Strain.Descriptor(childComplexity), true

	case "Strain.species":
		if e.complexity.Strain.Species == nil {
			break
		}

		return e.complexity.Strain.Species(childComplexity), true

	case "Strain.plasmid":
		if e.complexity.Strain.Plasmid == nil {
			break
		}

		return e.complexity.Strain.Plasmid(childComplexity), true

	case "Strain.parent":
		if e.complexity.Strain.Parent == nil {
			break
		}

		return e.complexity.Strain.Parent(childComplexity), true

	case "Strain.names":
		if e.complexity.Strain.Names == nil {
			break
		}

		return e.complexity.Strain.Names(childComplexity), true

	case "Strain.in_stock":
		if e.complexity.Strain.InStock == nil {
			break
		}

		return e.complexity.Strain.InStock(childComplexity), true

	case "Strain.phenotypes":
		if e.complexity.Strain.Phenotypes == nil {
			break
		}

		return e.complexity.Strain.Phenotypes(childComplexity), true

	case "Strain.genetic_modification":
		if e.complexity.Strain.GeneticModification == nil {
			break
		}

		return e.complexity.Strain.GeneticModification(childComplexity), true

	case "Strain.mutagenesis_method":
		if e.complexity.Strain.MutagenesisMethod == nil {
			break
		}

		return e.complexity.Strain.MutagenesisMethod(childComplexity), true

	case "Strain.characteristics":
		if e.complexity.Strain.Characteristics == nil {
			break
		}

		return e.complexity.Strain.Characteristics(childComplexity), true

	case "Strain.genotypes":
		if e.complexity.Strain.Genotypes == nil {
			break
		}

		return e.complexity.Strain.Genotypes(childComplexity), true

	case "StrainListWithCursor.strains":
		if e.complexity.StrainListWithCursor.Strains == nil {
			break
		}

		return e.complexity.StrainListWithCursor.Strains(childComplexity), true

	case "StrainListWithCursor.nextCursor":
		if e.complexity.StrainListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.StrainListWithCursor.NextCursor(childComplexity), true

	case "StrainListWithCursor.previousCursor":
		if e.complexity.StrainListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.StrainListWithCursor.PreviousCursor(childComplexity), true

	case "StrainListWithCursor.limit":
		if e.complexity.StrainListWithCursor.Limit == nil {
			break
		}

		return e.complexity.StrainListWithCursor.Limit(childComplexity), true

	case "StrainListWithCursor.totalCount":
		if e.complexity.StrainListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.StrainListWithCursor.TotalCount(childComplexity), true

	case "User.id":
		if e.complexity.User.Id == nil {
			break
		}

		return e.complexity.User.Id(childComplexity), true

	case "User.first_name":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.last_name":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.organization":
		if e.complexity.User.Organization == nil {
			break
		}

		return e.complexity.User.Organization(childComplexity), true

	case "User.group_name":
		if e.complexity.User.GroupName == nil {
			break
		}

		return e.complexity.User.GroupName(childComplexity), true

	case "User.first_address":
		if e.complexity.User.FirstAddress == nil {
			break
		}

		return e.complexity.User.FirstAddress(childComplexity), true

	case "User.second_address":
		if e.complexity.User.SecondAddress == nil {
			break
		}

		return e.complexity.User.SecondAddress(childComplexity), true

	case "User.city":
		if e.complexity.User.City == nil {
			break
		}

		return e.complexity.User.City(childComplexity), true

	case "User.state":
		if e.complexity.User.State == nil {
			break
		}

		return e.complexity.User.State(childComplexity), true

	case "User.zipcode":
		if e.complexity.User.Zipcode == nil {
			break
		}

		return e.complexity.User.Zipcode(childComplexity), true

	case "User.country":
		if e.complexity.User.Country == nil {
			break
		}

		return e.complexity.User.Country(childComplexity), true

	case "User.phone":
		if e.complexity.User.Phone == nil {
			break
		}

		return e.complexity.User.Phone(childComplexity), true

	case "User.is_active":
		if e.complexity.User.IsActive == nil {
			break
		}

		return e.complexity.User.IsActive(childComplexity), true

	case "User.created_at":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.updated_at":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "UserList.users":
		if e.complexity.UserList.Users == nil {
			break
		}

		return e.complexity.UserList.Users(childComplexity), true

	case "UserList.pageNum":
		if e.complexity.UserList.PageNum == nil {
			break
		}

		return e.complexity.UserList.PageNum(childComplexity), true

	case "UserList.pageSize":
		if e.complexity.UserList.PageSize == nil {
			break
		}

		return e.complexity.UserList.PageSize(childComplexity), true

	case "UserList.totalCount":
		if e.complexity.UserList.TotalCount == nil {
			break
		}

		return e.complexity.UserList.TotalCount(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var authorImplementors = []string{"Author"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Author(ctx context.Context, sel ast.SelectionSet, obj *publication.Author) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, authorImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Author")
		case "last_name":
			out.Values[i] = ec._Author_last_name(ctx, field, obj)
		case "first_name":
			out.Values[i] = ec._Author_first_name(ctx, field, obj)
		case "initials":
			out.Values[i] = ec._Author_initials(ctx, field, obj)
		case "rank":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Author_rank(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Author_last_name(ctx context.Context, field graphql.CollectedField, obj *publication.Author) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Author",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Author_first_name(ctx context.Context, field graphql.CollectedField, obj *publication.Author) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Author",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Author_initials(ctx context.Context, field graphql.CollectedField, obj *publication.Author) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Author",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Initials, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Author_rank(ctx context.Context, field graphql.CollectedField, obj *publication.Author) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Author",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Author().Rank(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var deletePermissionImplementors = []string{"DeletePermission"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeletePermission(ctx context.Context, sel ast.SelectionSet, obj *models.DeletePermission) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deletePermissionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeletePermission")
		case "success":
			out.Values[i] = ec._DeletePermission_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeletePermission_success(ctx context.Context, field graphql.CollectedField, obj *models.DeletePermission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeletePermission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var deleteRoleImplementors = []string{"DeleteRole"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteRole(ctx context.Context, sel ast.SelectionSet, obj *models.DeleteRole) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteRoleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteRole")
		case "success":
			out.Values[i] = ec._DeleteRole_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteRole_success(ctx context.Context, field graphql.CollectedField, obj *models.DeleteRole) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteRole",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var deleteStockImplementors = []string{"DeleteStock"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteStock(ctx context.Context, sel ast.SelectionSet, obj *models.DeleteStock) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteStockImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteStock")
		case "success":
			out.Values[i] = ec._DeleteStock_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteStock_success(ctx context.Context, field graphql.CollectedField, obj *models.DeleteStock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteStock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var deleteUserImplementors = []string{"DeleteUser"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteUser(ctx context.Context, sel ast.SelectionSet, obj *models.DeleteUser) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteUserImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteUser")
		case "success":
			out.Values[i] = ec._DeleteUser_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteUser_success(ctx context.Context, field graphql.CollectedField, obj *models.DeleteUser) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteUser",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createStrain":
			out.Values[i] = ec._Mutation_createStrain(ctx, field)
		case "createPlasmid":
			out.Values[i] = ec._Mutation_createPlasmid(ctx, field)
		case "updateStrain":
			out.Values[i] = ec._Mutation_updateStrain(ctx, field)
		case "updatePlasmid":
			out.Values[i] = ec._Mutation_updatePlasmid(ctx, field)
		case "deleteStock":
			out.Values[i] = ec._Mutation_deleteStock(ctx, field)
		case "createUser":
			out.Values[i] = ec._Mutation_createUser(ctx, field)
		case "createUserRoleRelationship":
			out.Values[i] = ec._Mutation_createUserRoleRelationship(ctx, field)
		case "updateUser":
			out.Values[i] = ec._Mutation_updateUser(ctx, field)
		case "deleteUser":
			out.Values[i] = ec._Mutation_deleteUser(ctx, field)
		case "createRole":
			out.Values[i] = ec._Mutation_createRole(ctx, field)
		case "createRolePermissionRelationship":
			out.Values[i] = ec._Mutation_createRolePermissionRelationship(ctx, field)
		case "updateRole":
			out.Values[i] = ec._Mutation_updateRole(ctx, field)
		case "deleteRole":
			out.Values[i] = ec._Mutation_deleteRole(ctx, field)
		case "createPermission":
			out.Values[i] = ec._Mutation_createPermission(ctx, field)
		case "updatePermission":
			out.Values[i] = ec._Mutation_updatePermission(ctx, field)
		case "deletePermission":
			out.Values[i] = ec._Mutation_deletePermission(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createStrain(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createStrain_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateStrain(rctx, args["input"].(*models.CreateStrainInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*stock.Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Strain(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createPlasmid(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createPlasmid_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePlasmid(rctx, args["input"].(*models.CreatePlasmidInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*stock.Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Plasmid(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateStrain(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateStrain_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateStrain(rctx, args["id"].(string), args["input"].(*models.UpdateStrainInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*stock.Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Strain(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updatePlasmid(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updatePlasmid_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePlasmid(rctx, args["id"].(string), args["input"].(*models.UpdatePlasmidInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*stock.Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Plasmid(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteStock(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteStock_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteStock(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.DeleteStock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteStock(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createUser_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, args["input"].(*models.CreateUserInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._User(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createUserRoleRelationship(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createUserRoleRelationship_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUserRoleRelationship(rctx, args["userId"].(string), args["roleId"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._User(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateUser_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUser(rctx, args["id"].(string), args["input"].(*models.UpdateUserInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._User(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteUser_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteUser(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.DeleteUser)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteUser(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createRole(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createRole_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateRole(rctx, args["input"].(*models.CreateRoleInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Role(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createRolePermissionRelationship(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createRolePermissionRelationship_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateRolePermissionRelationship(rctx, args["roleId"].(string), args["permissionId"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Role(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateRole(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateRole_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateRole(rctx, args["id"].(string), args["input"].(*models.UpdateRoleInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Role(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteRole(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteRole_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteRole(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.DeleteRole)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteRole(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createPermission(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createPermission_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePermission(rctx, args["input"].(*models.CreatePermissionInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Permission(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updatePermission(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updatePermission_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePermission(rctx, args["id"].(string), args["input"].(*models.UpdatePermissionInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Permission(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deletePermission(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deletePermission_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePermission(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.DeletePermission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeletePermission(ctx, field.Selections, res)
}

var permissionImplementors = []string{"Permission"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Permission(ctx context.Context, sel ast.SelectionSet, obj *user.Permission) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, permissionImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Permission")
		case "id":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Permission_id(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "permission":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Permission_permission(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "description":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Permission_description(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "created_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Permission_created_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "updated_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Permission_updated_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "resource":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Permission_resource(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Permission_id(ctx context.Context, field graphql.CollectedField, obj *user.Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permission().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_permission(ctx context.Context, field graphql.CollectedField, obj *user.Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permission().Permission(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_description(ctx context.Context, field graphql.CollectedField, obj *user.Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permission().Description(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_created_at(ctx context.Context, field graphql.CollectedField, obj *user.Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permission().CreatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_updated_at(ctx context.Context, field graphql.CollectedField, obj *user.Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permission().UpdatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_resource(ctx context.Context, field graphql.CollectedField, obj *user.Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permission().Resource(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var phenotypeImplementors = []string{"Phenotype"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Phenotype(ctx context.Context, sel ast.SelectionSet, obj *models.Phenotype) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, phenotypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Phenotype")
		case "phenotype":
			out.Values[i] = ec._Phenotype_phenotype(ctx, field, obj)
		case "notes":
			out.Values[i] = ec._Phenotype_notes(ctx, field, obj)
		case "dbxrefs":
			out.Values[i] = ec._Phenotype_dbxrefs(ctx, field, obj)
		case "publications":
			out.Values[i] = ec._Phenotype_publications(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Phenotype_phenotype(ctx context.Context, field graphql.CollectedField, obj *models.Phenotype) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Phenotype",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phenotype, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Phenotype_notes(ctx context.Context, field graphql.CollectedField, obj *models.Phenotype) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Phenotype",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notes, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Phenotype_dbxrefs(ctx context.Context, field graphql.CollectedField, obj *models.Phenotype) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Phenotype",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbxrefs, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Phenotype_publications(ctx context.Context, field graphql.CollectedField, obj *models.Phenotype) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Phenotype",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Publications, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*publication.Publication)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Publication(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var plasmidImplementors = []string{"Plasmid"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Plasmid(ctx context.Context, sel ast.SelectionSet, obj *stock.Stock) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, plasmidImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Plasmid")
		case "id":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_id(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "created_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_created_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "updated_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_updated_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "created_by":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_created_by(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "updated_by":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_updated_by(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "summary":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_summary(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "editable_summary":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_editable_summary(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "depositor":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_depositor(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "genes":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_genes(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "dbxrefs":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_dbxrefs(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "publications":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_publications(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "image_map":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_image_map(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "sequence":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_sequence(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "in_stock":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_in_stock(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "keywords":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_keywords(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "genbank_accession":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Plasmid_genbank_accession(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_id(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_created_at(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().CreatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_updated_at(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().UpdatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_created_by(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().CreatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._User(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_updated_by(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().UpdatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._User(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_summary(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().Summary(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_editable_summary(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().EditableSummary(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_depositor(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().Depositor(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_genes(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().Genes(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_dbxrefs(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().Dbxrefs(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_publications(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().Publications(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*publication.Publication)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Publication(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_image_map(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().ImageMap(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_sequence(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().Sequence(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_in_stock(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().InStock(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_keywords(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().Keywords(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Plasmid_genbank_accession(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Plasmid",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plasmid().GenbankAccession(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var plasmidListWithCursorImplementors = []string{"PlasmidListWithCursor"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PlasmidListWithCursor(ctx context.Context, sel ast.SelectionSet, obj *models.PlasmidListWithCursor) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, plasmidListWithCursorImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlasmidListWithCursor")
		case "plasmids":
			out.Values[i] = ec._PlasmidListWithCursor_plasmids(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nextCursor":
			out.Values[i] = ec._PlasmidListWithCursor_nextCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "previousCursor":
			out.Values[i] = ec._PlasmidListWithCursor_previousCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "limit":
			out.Values[i] = ec._PlasmidListWithCursor_limit(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._PlasmidListWithCursor_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _PlasmidListWithCursor_plasmids(ctx context.Context, field graphql.CollectedField, obj *models.PlasmidListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PlasmidListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plasmids, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]stock.Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Plasmid(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _PlasmidListWithCursor_nextCursor(ctx context.Context, field graphql.CollectedField, obj *models.PlasmidListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PlasmidListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _PlasmidListWithCursor_previousCursor(ctx context.Context, field graphql.CollectedField, obj *models.PlasmidListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PlasmidListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _PlasmidListWithCursor_limit(ctx context.Context, field graphql.CollectedField, obj *models.PlasmidListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PlasmidListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _PlasmidListWithCursor_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.PlasmidListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PlasmidListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var publicationImplementors = []string{"Publication"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Publication(ctx context.Context, sel ast.SelectionSet, obj *publication.Publication) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, publicationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Publication")
		case "id":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_id(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "doi":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_doi(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "title":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_title(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "abstract":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_abstract(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "journal":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_journal(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "pub_date":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_pub_date(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "volume":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_volume(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "pages":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_pages(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "issn":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_issn(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "pub_type":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_pub_type(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "source":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_source(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "issue":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_issue(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "status":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_status(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "authors":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Publication_authors(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Publication_id(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_doi(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Doi(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_title(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Title(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_abstract(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Abstract(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_journal(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Journal(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_pub_date(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().PubDate(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return models.MarshalTimestamp(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_volume(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Volume(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_pages(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Pages(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_issn(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Issn(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_pub_type(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().PubType(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_source(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Source(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_issue(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Issue(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_status(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Status(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_authors(ctx context.Context, field graphql.CollectedField, obj *publication.Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Publication().Authors(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*publication.Author)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Author(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "publication":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_publication(ctx, field)
				wg.Done()
			}(i, field)
		case "plasmid":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_plasmid(ctx, field)
				wg.Done()
			}(i, field)
		case "strain":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_strain(ctx, field)
				wg.Done()
			}(i, field)
		case "listStrains":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listStrains(ctx, field)
				wg.Done()
			}(i, field)
		case "listPlasmids":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listPlasmids(ctx, field)
				wg.Done()
			}(i, field)
		case "user":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_user(ctx, field)
				wg.Done()
			}(i, field)
		case "userByEmail":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_userByEmail(ctx, field)
				wg.Done()
			}(i, field)
		case "listUsers":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listUsers(ctx, field)
				wg.Done()
			}(i, field)
		case "role":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_role(ctx, field)
				wg.Done()
			}(i, field)
		case "listRoles":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listRoles(ctx, field)
				wg.Done()
			}(i, field)
		case "permission":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_permission(ctx, field)
				wg.Done()
			}(i, field)
		case "listPermissions":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listPermissions(ctx, field)
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_publication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_publication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Publication(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*publication.Publication)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Publication(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_plasmid(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_plasmid_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Plasmid(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*stock.Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Plasmid(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_strain(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_strain_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Strain(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*stock.Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Strain(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listStrains(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_listStrains_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListStrains(rctx, args["input"].(*models.ListStockInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.StrainListWithCursor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._StrainListWithCursor(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listPlasmids(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_listPlasmids_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListPlasmids(rctx, args["input"].(*models.ListStockInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.PlasmidListWithCursor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._PlasmidListWithCursor(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_user_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._User(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_userByEmail(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_userByEmail_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserByEmail(rctx, args["email"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._User(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listUsers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_listUsers_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListUsers(rctx, args["pagenum"].(string), args["pagesize"].(string), args["filter"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.UserList)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._UserList(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_role(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_role_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Role(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Role(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listRoles(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListRoles(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]user.Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Role(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_permission(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_permission_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Permission(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*user.Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Permission(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listPermissions(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListPermissions(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]user.Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Permission(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var roleImplementors = []string{"Role"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Role(ctx context.Context, sel ast.SelectionSet, obj *user.Role) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roleImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Role")
		case "id":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Role_id(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "role":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Role_role(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "description":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Role_description(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "created_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Role_created_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "updated_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Role_updated_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "permissions":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Role_permissions(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Role_id(ctx context.Context, field graphql.CollectedField, obj *user.Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Role().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_role(ctx context.Context, field graphql.CollectedField, obj *user.Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Role().Role(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_description(ctx context.Context, field graphql.CollectedField, obj *user.Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Role().Description(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_created_at(ctx context.Context, field graphql.CollectedField, obj *user.Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Role().CreatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_updated_at(ctx context.Context, field graphql.CollectedField, obj *user.Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Role().UpdatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_permissions(ctx context.Context, field graphql.CollectedField, obj *user.Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Role().Permissions(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]user.Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Permission(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var strainImplementors = []string{"Strain"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Strain(ctx context.Context, sel ast.SelectionSet, obj *stock.Stock) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, strainImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Strain")
		case "id":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_id(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "created_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_created_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "updated_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_updated_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "created_by":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_created_by(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "updated_by":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_updated_by(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "summary":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_summary(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "editable_summary":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_editable_summary(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "depositor":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_depositor(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "genes":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_genes(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "dbxrefs":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_dbxrefs(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "publications":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_publications(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "systematic_name":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_systematic_name(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "descriptor":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_descriptor(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "species":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_species(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "plasmid":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_plasmid(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "parent":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_parent(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "names":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_names(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "in_stock":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_in_stock(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "phenotypes":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_phenotypes(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "genetic_modification":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_genetic_modification(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "mutagenesis_method":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_mutagenesis_method(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "characteristics":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_characteristics(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "genotypes":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Strain_genotypes(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Strain_id(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_created_at(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().CreatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_updated_at(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().UpdatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_created_by(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().CreatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._User(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_updated_by(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().UpdatedBy(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	return ec._User(ctx, field.Selections, &res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_summary(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Summary(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_editable_summary(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().EditableSummary(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_depositor(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Depositor(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_genes(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Genes(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Strain_dbxrefs(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Dbxrefs(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Strain_publications(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Publications(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*publication.Publication)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Publication(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Strain_systematic_name(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().SystematicName(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_descriptor(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Descriptor(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_species(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Species(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_plasmid(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Plasmid(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_parent(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Parent(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*stock.Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Strain(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_names(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Names(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Strain_in_stock(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().InStock(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_phenotypes(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Phenotypes(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Phenotype)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Phenotype(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Strain_genetic_modification(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().GeneticModification(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_mutagenesis_method(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().MutagenesisMethod(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Strain_characteristics(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Characteristics(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Strain_genotypes(ctx context.Context, field graphql.CollectedField, obj *stock.Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Strain",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Strain().Genotypes(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

var strainListWithCursorImplementors = []string{"StrainListWithCursor"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StrainListWithCursor(ctx context.Context, sel ast.SelectionSet, obj *models.StrainListWithCursor) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, strainListWithCursorImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StrainListWithCursor")
		case "strains":
			out.Values[i] = ec._StrainListWithCursor_strains(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nextCursor":
			out.Values[i] = ec._StrainListWithCursor_nextCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "previousCursor":
			out.Values[i] = ec._StrainListWithCursor_previousCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "limit":
			out.Values[i] = ec._StrainListWithCursor_limit(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._StrainListWithCursor_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StrainListWithCursor_strains(ctx context.Context, field graphql.CollectedField, obj *models.StrainListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Strains, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]stock.Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Strain(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _StrainListWithCursor_nextCursor(ctx context.Context, field graphql.CollectedField, obj *models.StrainListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StrainListWithCursor_previousCursor(ctx context.Context, field graphql.CollectedField, obj *models.StrainListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _StrainListWithCursor_limit(ctx context.Context, field graphql.CollectedField, obj *models.StrainListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _StrainListWithCursor_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.StrainListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var userImplementors = []string{"User"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *user.User) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, userImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_id(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "first_name":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_first_name(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "last_name":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_last_name(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "email":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_email(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "organization":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_organization(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "group_name":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_group_name(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "first_address":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_first_address(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "second_address":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_second_address(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "city":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_city(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "state":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_state(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "zipcode":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_zipcode(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "country":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_country(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "phone":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_phone(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "is_active":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_is_active(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "created_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_created_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "updated_at":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_updated_at(ctx, field, obj)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "roles":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._User_roles(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().ID(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_first_name(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().FirstName(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_last_name(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().LastName(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Email(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_organization(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Organization(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_group_name(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().GroupName(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_first_address(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().FirstAddress(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_second_address(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().SecondAddress(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_city(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().City(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_state(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().State(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_zipcode(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Zipcode(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_country(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Country(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_phone(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Phone(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_is_active(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().IsActive(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_created_at(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().CreatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_updated_at(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().UpdatedAt(rctx, obj)
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return models.MarshalTimestamp(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *user.User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Roles(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]user.Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Role(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var userListImplementors = []string{"UserList"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UserList(ctx context.Context, sel ast.SelectionSet, obj *models.UserList) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, userListImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserList")
		case "users":
			out.Values[i] = ec._UserList_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pageNum":
			out.Values[i] = ec._UserList_pageNum(ctx, field, obj)
		case "pageSize":
			out.Values[i] = ec._UserList_pageSize(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._UserList_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UserList_users(ctx context.Context, field graphql.CollectedField, obj *models.UserList) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UserList",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]user.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._User(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _UserList_pageNum(ctx context.Context, field graphql.CollectedField, obj *models.UserList) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UserList",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageNum, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _UserList_pageSize(ctx context.Context, field graphql.CollectedField, obj *models.UserList) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UserList",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageSize, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _UserList_totalCount(ctx context.Context, field graphql.CollectedField, obj *models.UserList) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UserList",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func UnmarshalCreatePermissionInput(v interface{}) (models.CreatePermissionInput, error) {
	var it models.CreatePermissionInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "permission":
			var err error
			it.Permission, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			it.Resource, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreatePlasmidInput(v interface{}) (models.CreatePlasmidInput, error) {
	var it models.CreatePlasmidInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "created_by":
			var err error
			it.CreatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "updated_by":
			var err error
			it.UpdatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Summary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "editable_summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.EditableSummary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "depositor":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Depositor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "genes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Genes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Genes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "dbxrefs":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Dbxrefs = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Dbxrefs[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "publications":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Publications = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Publications[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "image_map":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ImageMap = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "sequence":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Sequence = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "in_stock":
			var err error
			it.InStock, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		case "keywords":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Keywords = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Keywords[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "genbank_accession":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.GenbankAccession = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateRoleInput(v interface{}) (models.CreateRoleInput, error) {
	var it models.CreateRoleInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "role":
			var err error
			it.Role, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateStrainInput(v interface{}) (models.CreateStrainInput, error) {
	var it models.CreateStrainInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "created_by":
			var err error
			it.CreatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "updated_by":
			var err error
			it.UpdatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Summary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "editable_summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.EditableSummary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "depositor":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Depositor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "genes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Genes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Genes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "dbxrefs":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Dbxrefs = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Dbxrefs[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "publications":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Publications = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Publications[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "systematic_name":
			var err error
			it.SystematicName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "descriptor":
			var err error
			it.Descriptor, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "species":
			var err error
			it.Species, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "plasmid":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Plasmid = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "parent":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Parent = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "names":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Names = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Names[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "in_stock":
			var err error
			it.InStock, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		case "phenotypes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Phenotypes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Phenotypes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "genetic_modification":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.GeneticModification = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "mutagenesis_method":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.MutagenesisMethod = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "characteristics":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Characteristics = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Characteristics[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "genotypes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Genotypes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Genotypes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateUserInput(v interface{}) (models.CreateUserInput, error) {
	var it models.CreateUserInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "first_name":
			var err error
			it.FirstName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "last_name":
			var err error
			it.LastName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "organization":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Organization = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "group_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.GroupName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "first_address":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FirstAddress = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "second_address":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.SecondAddress = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "city":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.City = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "state":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.State = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "zipcode":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Zipcode = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "country":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Country = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "phone":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Phone = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "is_active":
			var err error
			it.IsActive, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalListStockInput(v interface{}) (models.ListStockInput, error) {
	var it models.ListStockInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "cursor":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Cursor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "limit":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Limit = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "filter":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Filter = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdatePermissionInput(v interface{}) (models.UpdatePermissionInput, error) {
	var it models.UpdatePermissionInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "permission":
			var err error
			it.Permission, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			it.Resource, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdatePlasmidInput(v interface{}) (models.UpdatePlasmidInput, error) {
	var it models.UpdatePlasmidInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "updated_by":
			var err error
			it.UpdatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Summary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "editable_summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.EditableSummary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "depositor":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Depositor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "genes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Genes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Genes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "dbxrefs":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Dbxrefs = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Dbxrefs[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "publications":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Publications = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Publications[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "image_map":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ImageMap = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "sequence":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Sequence = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "in_stock":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.InStock = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "keywords":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Keywords = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Keywords[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "genbank_accession":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.GenbankAccession = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateRoleInput(v interface{}) (models.UpdateRoleInput, error) {
	var it models.UpdateRoleInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "role":
			var err error
			it.Role, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateStrainInput(v interface{}) (models.UpdateStrainInput, error) {
	var it models.UpdateStrainInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "updated_by":
			var err error
			it.UpdatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Summary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "editable_summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.EditableSummary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "depositor":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Depositor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "genes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Genes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Genes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "dbxrefs":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Dbxrefs = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Dbxrefs[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "publications":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Publications = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Publications[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "systematic_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.SystematicName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "descriptor":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Descriptor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "species":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Species = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plasmid":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Plasmid = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "parent":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Parent = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "names":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Names = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Names[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "in_stock":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.InStock = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "phenotypes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Phenotypes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Phenotypes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "genetic_modification":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.GeneticModification = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "mutagenesis_method":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.MutagenesisMethod = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "characteristics":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Characteristics = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Characteristics[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "genotypes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Genotypes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Genotypes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateUserInput(v interface{}) (models.UpdateUserInput, error) {
	var it models.UpdateUserInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "first_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FirstName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "last_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.LastName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "organization":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Organization = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "group_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.GroupName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "first_address":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FirstAddress = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "second_address":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.SecondAddress = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "city":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.City = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "state":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.State = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "zipcode":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Zipcode = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "country":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Country = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "phone":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Phone = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "is_active":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.IsActive = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "api/mutation.graphql", Input: `type Mutation {
  # Order mutations
  # createOrder(input: CreateOrderInput): Order
  # updateOrder(id: ID!, input: UpdateOrderInput): Order
  # Stock mutations
  createStrain(input: CreateStrainInput): Strain
  createPlasmid(input: CreatePlasmidInput): Plasmid
  updateStrain(id: ID!, input: UpdateStrainInput): Strain
  updatePlasmid(id: ID!, input: UpdatePlasmidInput): Plasmid
  deleteStock(id: ID!): DeleteStock
  # User mutations
  createUser(input: CreateUserInput): User
  createUserRoleRelationship(userId: ID!, roleId: ID!): User
  updateUser(id: ID!, input: UpdateUserInput): User
  deleteUser(id: ID!): DeleteUser
  createRole(input: CreateRoleInput): Role
  createRolePermissionRelationship(roleId: ID!, permissionId: ID!): Role
  updateRole(id: ID!, input: UpdateRoleInput): Role
  deleteRole(id: ID!): DeleteRole
  createPermission(input: CreatePermissionInput): Permission
  updatePermission(id: ID!, input: UpdatePermissionInput): Permission
  deletePermission(id: ID!): DeletePermission
}
`},
	&ast.Source{Name: "api/publication.graphql", Input: `type Publication {
  id: ID!
  doi: String
  title: String
  abstract: String
  journal: String
  pub_date: Timestamp
  volume: String
  pages: String
  issn: String
  pub_type: String
  source: String
  issue: String
  status: String
  authors: [Author]
}

type Author {
  last_name: String
  first_name: String
  initials: String
  rank: String
}

# type PublicationListWithCursor {
#   publications: [Publication!]!
#   nextCursor: ID!
#   previousCursor: ID!
#   limit: Int
#   totalCount: Int!
# }

# input CreatePublicationInput {
#   doi: String
#   title: String
#   abstract: String
#   journal: String
#   pub_date: Timestamp
#   volume: String
#   pages: String
#   issn: String
#   pub_type: String
#   source: String
#   issue: String
#   status: String
#   authors: [CreateAuthorInput]
# }

# input CreateAuthorInput {
#   last_name: String
#   first_name: String
#   initials: String
#   rank: String
# }

# input UpdatePublicationInput {
#   pub_date: String
#   volume: String
#   pages: String
#   pub_type: String
#   source: String
#   status: String
#   authors: [UpdateAuthorInput]
# }

# input UpdateAuthorInput {
#   last_name: String
#   first_name: String
#   initials: String
#   rank: String
# }

# type DeletePublication {
#   success: Boolean!
# }
`},
	&ast.Source{Name: "api/query.graphql", Input: `type Query {
  # Order queries
  # order(id: ID!): Order
  # listOrders(input: ListOrderInput): OrderListWithCursor
  # Publication queries
  publication(id: ID!): Publication
  # Stock queries
  plasmid(id: ID!): Plasmid
  strain(id: ID!): Strain
  listStrains(input: ListStockInput): StrainListWithCursor
  listPlasmids(input: ListStockInput): PlasmidListWithCursor
  # User queries
  user(id: ID!): User
  userByEmail(email: String!): User
  listUsers(pagenum: String!, pagesize: String!, filter: String!): UserList
  role(id: ID!): Role
  listRoles: [Role!]
  permission(id: ID!): Permission
  listPermissions: [Permission!]
}
`},
	&ast.Source{Name: "api/scalar.graphql", Input: `scalar Timestamp
`},
	&ast.Source{Name: "api/stock.graphql", Input: `type Strain {
  id: ID!
  created_at: Timestamp!
  updated_at: Timestamp!
  created_by: User!
  updated_by: User!
  summary: String
  editable_summary: String
  depositor: String!
  genes: [String]
  dbxrefs: [String]
  publications: [Publication]
  # from strain_properties
  systematic_name: String!
  descriptor: String!
  species: String!
  plasmid: String # update to Plasmid later?
  parent: Strain
  names: [String]
  # new additions
  in_stock: Boolean!
  phenotypes: [Phenotype]
  genetic_modification: String
  mutagenesis_method: String
  characteristics: [String]
  genotypes: [String]
}

type Phenotype {
  phenotype: String
  notes: String
  dbxrefs: [String]
  publications: [Publication]
}

type Plasmid {
  id: ID!
  created_at: Timestamp!
  updated_at: Timestamp!
  created_by: User!
  updated_by: User!
  summary: String # same as description field?
  editable_summary: String
  depositor: String!
  genes: [String]
  dbxrefs: [String]
  publications: [Publication]
  # from plasmid_properties
  image_map: String
  sequence: String
  # new additions
  in_stock: Boolean!
  keywords: [String]
  genbank_accession: String
}

type StrainListWithCursor {
  strains: [Strain!]!
  nextCursor: Int!
  previousCursor: Int!
  limit: Int
  totalCount: Int!
}

type PlasmidListWithCursor {
  plasmids: [Plasmid!]!
  nextCursor: Int!
  previousCursor: Int!
  limit: Int
  totalCount: Int!
}

type DeleteStock {
  success: Boolean!
}

input CreateStrainInput {
  created_by: String!
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String]
  dbxrefs: [String]
  publications: [String]
  # from strain_properties
  systematic_name: String!
  descriptor: String!
  species: String!
  plasmid: String
  parent: String
  names: [String]
  # new additions
  in_stock: Boolean!
  phenotypes: [String]
  genetic_modification: String
  mutagenesis_method: String
  characteristics: [String]
  genotypes: [String]
}

input CreatePlasmidInput {
  created_by: String!
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String]
  dbxrefs: [String]
  publications: [String]
  # from plasmid_properties
  image_map: String
  sequence: String
  # new additions
  in_stock: Boolean!
  keywords: [String]
  genbank_accession: String
}

input UpdateStrainInput {
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String]
  dbxrefs: [String]
  publications: [String]
  # from strain_properties
  systematic_name: String
  descriptor: String
  species: String
  plasmid: String
  parent: String
  names: [String]
  # new additions
  in_stock: Boolean
  phenotypes: [String]
  genetic_modification: String
  mutagenesis_method: String
  characteristics: [String]
  genotypes: [String]
}

input UpdatePlasmidInput {
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String]
  dbxrefs: [String]
  publications: [String]
  # from plasmid_properties
  image_map: String
  sequence: String
  # new additions
  in_stock: Boolean
  keywords: [String]
  genbank_accession: String
}

input ListStockInput {
  cursor: Int
  limit: Int
  filter: String
}
`},
	&ast.Source{Name: "api/user.graphql", Input: `type Permission {
  id: ID!
  permission: String!
  description: String!
  created_at: Timestamp!
  updated_at: Timestamp!
  resource: String
}

type Role {
  id: ID!
  role: String!
  description: String!
  created_at: Timestamp!
  updated_at: Timestamp!
  permissions: [Permission!]
}

type User {
  id: ID!
  first_name: String!
  last_name: String!
  email: String!
  organization: String
  group_name: String
  first_address: String
  second_address: String
  city: String
  state: String
  zipcode: String
  country: String
  phone: String
  is_active: Boolean!
  created_at: Timestamp!
  updated_at: Timestamp!
  roles: [Role!]
}

type UserList {
  users: [User!]!
  pageNum: String
  pageSize: String
  totalCount: Int!
}

input CreateUserInput {
  first_name: String!
  last_name: String!
  email: String!
  organization: String
  group_name: String
  first_address: String
  second_address: String
  city: String
  state: String
  zipcode: String
  country: String
  phone: String
  is_active: Boolean!
}

input UpdateUserInput {
  first_name: String
  last_name: String
  organization: String
  group_name: String
  first_address: String
  second_address: String
  city: String
  state: String
  zipcode: String
  country: String
  phone: String
  is_active: Boolean
}

input CreateRoleInput {
  role: String!
  description: String!
}

input UpdateRoleInput {
  role: String!
  description: String!
}

input CreatePermissionInput {
  permission: String!
  description: String!
  resource: String!
}

input UpdatePermissionInput {
  permission: String!
  description: String!
  resource: String!
}

type DeleteUser {
  success: Boolean!
}

type DeleteRole {
  success: Boolean!
}

type DeletePermission {
  success: Boolean!
}
`},
)
