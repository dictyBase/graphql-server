// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/dictyBase/graphql-server/internal/graphql/models"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Auth() AuthResolver
	Author() AuthorResolver
	Content() ContentResolver
	Mutation() MutationResolver
	Order() OrderResolver
	Organism() OrganismResolver
	Permission() PermissionResolver
	Plasmid() PlasmidResolver
	Query() QueryResolver
	Role() RoleResolver
	Strain() StrainResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Auth struct {
		Identity func(childComplexity int) int
		Token    func(childComplexity int) int
		User     func(childComplexity int) int
	}

	Author struct {
		FirstName func(childComplexity int) int
		Initials  func(childComplexity int) int
		LastName  func(childComplexity int) int
		Rank      func(childComplexity int) int
	}

	Citation struct {
		Authors  func(childComplexity int) int
		Journal  func(childComplexity int) int
		PubmedID func(childComplexity int) int
		Title    func(childComplexity int) int
	}

	Content struct {
		Content   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		CreatedBy func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Namespace func(childComplexity int) int
		Slug      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UpdatedBy func(childComplexity int) int
	}

	DeleteContent struct {
		Success func(childComplexity int) int
	}

	DeletePermission struct {
		Success func(childComplexity int) int
	}

	DeleteRole struct {
		Success func(childComplexity int) int
	}

	DeleteStock struct {
		Success func(childComplexity int) int
	}

	DeleteUser struct {
		Success func(childComplexity int) int
	}

	Download struct {
		Items func(childComplexity int) int
		Title func(childComplexity int) int
	}

	DownloadItem struct {
		Title func(childComplexity int) int
		URL   func(childComplexity int) int
	}

	Extension struct {
		Db       func(childComplexity int) int
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		Relation func(childComplexity int) int
	}

	GOAnnotation struct {
		AssignedBy   func(childComplexity int) int
		Date         func(childComplexity int) int
		EvidenceCode func(childComplexity int) int
		Extensions   func(childComplexity int) int
		GoTerm       func(childComplexity int) int
		ID           func(childComplexity int) int
		Publication  func(childComplexity int) int
		Qualifier    func(childComplexity int) int
		Type         func(childComplexity int) int
		With         func(childComplexity int) int
	}

	Gene struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	GeneGeneralInfo struct {
		Description     func(childComplexity int) int
		GeneProduct     func(childComplexity int) int
		ID              func(childComplexity int) int
		NameDescription func(childComplexity int) int
		Synonyms        func(childComplexity int) int
	}

	Identity struct {
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		Identifier func(childComplexity int) int
		Provider   func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	ImageFile struct {
		URL func(childComplexity int) int
	}

	Logout struct {
		Success func(childComplexity int) int
	}

	Mutation struct {
		CreateContent                    func(childComplexity int, input *models.CreateContentInput) int
		CreateOrder                      func(childComplexity int, input *models.CreateOrderInput) int
		CreatePermission                 func(childComplexity int, input *models.CreatePermissionInput) int
		CreatePlasmid                    func(childComplexity int, input *models.CreatePlasmidInput) int
		CreateRole                       func(childComplexity int, input *models.CreateRoleInput) int
		CreateRolePermissionRelationship func(childComplexity int, roleID string, permissionID string) int
		CreateStrain                     func(childComplexity int, input *models.CreateStrainInput) int
		CreateUser                       func(childComplexity int, input *models.CreateUserInput) int
		CreateUserRoleRelationship       func(childComplexity int, userID string, roleID string) int
		DeleteContent                    func(childComplexity int, id string) int
		DeletePermission                 func(childComplexity int, id string) int
		DeleteRole                       func(childComplexity int, id string) int
		DeleteStock                      func(childComplexity int, id string) int
		DeleteUser                       func(childComplexity int, id string) int
		Login                            func(childComplexity int, input *models.LoginInput) int
		Logout                           func(childComplexity int) int
		UpdateContent                    func(childComplexity int, input *models.UpdateContentInput) int
		UpdateOrder                      func(childComplexity int, id string, input *models.UpdateOrderInput) int
		UpdatePermission                 func(childComplexity int, id string, input *models.UpdatePermissionInput) int
		UpdatePlasmid                    func(childComplexity int, id string, input *models.UpdatePlasmidInput) int
		UpdateRole                       func(childComplexity int, id string, input *models.UpdateRoleInput) int
		UpdateStrain                     func(childComplexity int, id string, input *models.UpdateStrainInput) int
		UpdateUser                       func(childComplexity int, id string, input *models.UpdateUserInput) int
		UploadFile                       func(childComplexity int, file graphql.Upload) int
	}

	NumberOfPublicationsWithGene struct {
		NumPubs      func(childComplexity int) int
		Publications func(childComplexity int) int
	}

	Order struct {
		Comments         func(childComplexity int) int
		Consumer         func(childComplexity int) int
		Courier          func(childComplexity int) int
		CourierAccount   func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		Items            func(childComplexity int) int
		Payer            func(childComplexity int) int
		Payment          func(childComplexity int) int
		PurchaseOrderNum func(childComplexity int) int
		Purchaser        func(childComplexity int) int
		Status           func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	OrderListWithCursor struct {
		Limit          func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		Orders         func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	Organism struct {
		Citations      func(childComplexity int) int
		Downloads      func(childComplexity int) int
		ScientificName func(childComplexity int) int
		TaxonID        func(childComplexity int) int
	}

	Permission struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Permission  func(childComplexity int) int
		Resource    func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Phenotype struct {
		Assay       func(childComplexity int) int
		Environment func(childComplexity int) int
		Note        func(childComplexity int) int
		Phenotype   func(childComplexity int) int
		Publication func(childComplexity int) int
	}

	Plasmid struct {
		CreatedAt        func(childComplexity int) int
		CreatedBy        func(childComplexity int) int
		Dbxrefs          func(childComplexity int) int
		Depositor        func(childComplexity int) int
		EditableSummary  func(childComplexity int) int
		GenbankAccession func(childComplexity int) int
		Genes            func(childComplexity int) int
		ID               func(childComplexity int) int
		ImageMap         func(childComplexity int) int
		InStock          func(childComplexity int) int
		Keywords         func(childComplexity int) int
		Name             func(childComplexity int) int
		Publications     func(childComplexity int) int
		Sequence         func(childComplexity int) int
		Summary          func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		UpdatedBy        func(childComplexity int) int
	}

	PlasmidListWithCursor struct {
		Limit          func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		Plasmids       func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	Publication struct {
		Abstract func(childComplexity int) int
		Authors  func(childComplexity int) int
		Doi      func(childComplexity int) int
		ID       func(childComplexity int) int
		Issn     func(childComplexity int) int
		Issue    func(childComplexity int) int
		Journal  func(childComplexity int) int
		Pages    func(childComplexity int) int
		PubDate  func(childComplexity int) int
		PubType  func(childComplexity int) int
		Source   func(childComplexity int) int
		Status   func(childComplexity int) int
		Title    func(childComplexity int) int
		Volume   func(childComplexity int) int
	}

	PublicationWithGene struct {
		Abstract     func(childComplexity int) int
		Authors      func(childComplexity int) int
		Doi          func(childComplexity int) int
		ID           func(childComplexity int) int
		Issn         func(childComplexity int) int
		Issue        func(childComplexity int) int
		Journal      func(childComplexity int) int
		Pages        func(childComplexity int) int
		PubDate      func(childComplexity int) int
		PubType      func(childComplexity int) int
		RelatedGenes func(childComplexity int) int
		Source       func(childComplexity int) int
		Status       func(childComplexity int) int
		Title        func(childComplexity int) int
		Volume       func(childComplexity int) int
	}

	Query struct {
		Content                    func(childComplexity int, id string) int
		ContentBySlug              func(childComplexity int, slug string) int
		GeneGeneralInformation     func(childComplexity int, gene string) int
		GeneOntologyAnnotation     func(childComplexity int, gene string) int
		ListContentByNamespace     func(childComplexity int, namespace string) int
		ListOrders                 func(childComplexity int, cursor *int, limit *int, filter *string) int
		ListOrganisms              func(childComplexity int) int
		ListPermissions            func(childComplexity int) int
		ListPlasmids               func(childComplexity int, cursor *int, limit *int, filter *string) int
		ListPlasmidsWithAnnotation func(childComplexity int, cursor *int, limit *int, typeArg string, annotation string) int
		ListPublicationsWithGene   func(childComplexity int, gene string) int
		ListRecentPlasmids         func(childComplexity int, limit int) int
		ListRecentPublications     func(childComplexity int, limit int) int
		ListRecentStrains          func(childComplexity int, limit int) int
		ListRoles                  func(childComplexity int) int
		ListStrains                func(childComplexity int, cursor *int, limit *int, filter *models.StrainListFilter) int
		ListStrainsWithAnnotation  func(childComplexity int, cursor *int, limit *int, typeArg string, annotation string) int
		ListStrainsWithGene        func(childComplexity int, gene string) int
		ListUsers                  func(childComplexity int, pagenum string, pagesize string, filter string) int
		Order                      func(childComplexity int, id string) int
		Organism                   func(childComplexity int, taxonID string) int
		Permission                 func(childComplexity int, id string) int
		Plasmid                    func(childComplexity int, id string) int
		Publication                func(childComplexity int, id string) int
		Role                       func(childComplexity int, id string) int
		Strain                     func(childComplexity int, id string) int
		User                       func(childComplexity int, id string) int
		UserByEmail                func(childComplexity int, email string) int
	}

	Role struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Permissions func(childComplexity int) int
		Role        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Strain struct {
		Characteristics     func(childComplexity int) int
		CreatedAt           func(childComplexity int) int
		CreatedBy           func(childComplexity int) int
		Dbxrefs             func(childComplexity int) int
		Depositor           func(childComplexity int) int
		EditableSummary     func(childComplexity int) int
		Genes               func(childComplexity int) int
		GeneticModification func(childComplexity int) int
		Genotypes           func(childComplexity int) int
		ID                  func(childComplexity int) int
		InStock             func(childComplexity int) int
		Label               func(childComplexity int) int
		MutagenesisMethod   func(childComplexity int) int
		Names               func(childComplexity int) int
		Parent              func(childComplexity int) int
		Phenotypes          func(childComplexity int) int
		Plasmid             func(childComplexity int) int
		Publications        func(childComplexity int) int
		Species             func(childComplexity int) int
		Summary             func(childComplexity int) int
		SystematicName      func(childComplexity int) int
		UpdatedAt           func(childComplexity int) int
		UpdatedBy           func(childComplexity int) int
	}

	StrainListWithCursor struct {
		Limit          func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		Strains        func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	User struct {
		City          func(childComplexity int) int
		Country       func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		Email         func(childComplexity int) int
		FirstAddress  func(childComplexity int) int
		FirstName     func(childComplexity int) int
		GroupName     func(childComplexity int) int
		ID            func(childComplexity int) int
		IsActive      func(childComplexity int) int
		LastName      func(childComplexity int) int
		Organization  func(childComplexity int) int
		Phone         func(childComplexity int) int
		Roles         func(childComplexity int) int
		SecondAddress func(childComplexity int) int
		State         func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Zipcode       func(childComplexity int) int
	}

	UserList struct {
		PageNum    func(childComplexity int) int
		PageSize   func(childComplexity int) int
		TotalCount func(childComplexity int) int
		Users      func(childComplexity int) int
	}

	With struct {
		Db   func(childComplexity int) int
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Auth.identity":
		if e.complexity.Auth.Identity == nil {
			break
		}

		return e.complexity.Auth.Identity(childComplexity), true

	case "Auth.token":
		if e.complexity.Auth.Token == nil {
			break
		}

		return e.complexity.Auth.Token(childComplexity), true

	case "Auth.user":
		if e.complexity.Auth.User == nil {
			break
		}

		return e.complexity.Auth.User(childComplexity), true

	case "Author.first_name":
		if e.complexity.Author.FirstName == nil {
			break
		}

		return e.complexity.Author.FirstName(childComplexity), true

	case "Author.initials":
		if e.complexity.Author.Initials == nil {
			break
		}

		return e.complexity.Author.Initials(childComplexity), true

	case "Author.last_name":
		if e.complexity.Author.LastName == nil {
			break
		}

		return e.complexity.Author.LastName(childComplexity), true

	case "Author.rank":
		if e.complexity.Author.Rank == nil {
			break
		}

		return e.complexity.Author.Rank(childComplexity), true

	case "Citation.authors":
		if e.complexity.Citation.Authors == nil {
			break
		}

		return e.complexity.Citation.Authors(childComplexity), true

	case "Citation.journal":
		if e.complexity.Citation.Journal == nil {
			break
		}

		return e.complexity.Citation.Journal(childComplexity), true

	case "Citation.pubmed_id":
		if e.complexity.Citation.PubmedID == nil {
			break
		}

		return e.complexity.Citation.PubmedID(childComplexity), true

	case "Citation.title":
		if e.complexity.Citation.Title == nil {
			break
		}

		return e.complexity.Citation.Title(childComplexity), true

	case "Content.content":
		if e.complexity.Content.Content == nil {
			break
		}

		return e.complexity.Content.Content(childComplexity), true

	case "Content.created_at":
		if e.complexity.Content.CreatedAt == nil {
			break
		}

		return e.complexity.Content.CreatedAt(childComplexity), true

	case "Content.created_by":
		if e.complexity.Content.CreatedBy == nil {
			break
		}

		return e.complexity.Content.CreatedBy(childComplexity), true

	case "Content.id":
		if e.complexity.Content.ID == nil {
			break
		}

		return e.complexity.Content.ID(childComplexity), true

	case "Content.name":
		if e.complexity.Content.Name == nil {
			break
		}

		return e.complexity.Content.Name(childComplexity), true

	case "Content.namespace":
		if e.complexity.Content.Namespace == nil {
			break
		}

		return e.complexity.Content.Namespace(childComplexity), true

	case "Content.slug":
		if e.complexity.Content.Slug == nil {
			break
		}

		return e.complexity.Content.Slug(childComplexity), true

	case "Content.updated_at":
		if e.complexity.Content.UpdatedAt == nil {
			break
		}

		return e.complexity.Content.UpdatedAt(childComplexity), true

	case "Content.updated_by":
		if e.complexity.Content.UpdatedBy == nil {
			break
		}

		return e.complexity.Content.UpdatedBy(childComplexity), true

	case "DeleteContent.success":
		if e.complexity.DeleteContent.Success == nil {
			break
		}

		return e.complexity.DeleteContent.Success(childComplexity), true

	case "DeletePermission.success":
		if e.complexity.DeletePermission.Success == nil {
			break
		}

		return e.complexity.DeletePermission.Success(childComplexity), true

	case "DeleteRole.success":
		if e.complexity.DeleteRole.Success == nil {
			break
		}

		return e.complexity.DeleteRole.Success(childComplexity), true

	case "DeleteStock.success":
		if e.complexity.DeleteStock.Success == nil {
			break
		}

		return e.complexity.DeleteStock.Success(childComplexity), true

	case "DeleteUser.success":
		if e.complexity.DeleteUser.Success == nil {
			break
		}

		return e.complexity.DeleteUser.Success(childComplexity), true

	case "Download.items":
		if e.complexity.Download.Items == nil {
			break
		}

		return e.complexity.Download.Items(childComplexity), true

	case "Download.title":
		if e.complexity.Download.Title == nil {
			break
		}

		return e.complexity.Download.Title(childComplexity), true

	case "DownloadItem.title":
		if e.complexity.DownloadItem.Title == nil {
			break
		}

		return e.complexity.DownloadItem.Title(childComplexity), true

	case "DownloadItem.url":
		if e.complexity.DownloadItem.URL == nil {
			break
		}

		return e.complexity.DownloadItem.URL(childComplexity), true

	case "Extension.db":
		if e.complexity.Extension.Db == nil {
			break
		}

		return e.complexity.Extension.Db(childComplexity), true

	case "Extension.id":
		if e.complexity.Extension.ID == nil {
			break
		}

		return e.complexity.Extension.ID(childComplexity), true

	case "Extension.name":
		if e.complexity.Extension.Name == nil {
			break
		}

		return e.complexity.Extension.Name(childComplexity), true

	case "Extension.relation":
		if e.complexity.Extension.Relation == nil {
			break
		}

		return e.complexity.Extension.Relation(childComplexity), true

	case "GOAnnotation.assigned_by":
		if e.complexity.GOAnnotation.AssignedBy == nil {
			break
		}

		return e.complexity.GOAnnotation.AssignedBy(childComplexity), true

	case "GOAnnotation.date":
		if e.complexity.GOAnnotation.Date == nil {
			break
		}

		return e.complexity.GOAnnotation.Date(childComplexity), true

	case "GOAnnotation.evidence_code":
		if e.complexity.GOAnnotation.EvidenceCode == nil {
			break
		}

		return e.complexity.GOAnnotation.EvidenceCode(childComplexity), true

	case "GOAnnotation.extensions":
		if e.complexity.GOAnnotation.Extensions == nil {
			break
		}

		return e.complexity.GOAnnotation.Extensions(childComplexity), true

	case "GOAnnotation.go_term":
		if e.complexity.GOAnnotation.GoTerm == nil {
			break
		}

		return e.complexity.GOAnnotation.GoTerm(childComplexity), true

	case "GOAnnotation.id":
		if e.complexity.GOAnnotation.ID == nil {
			break
		}

		return e.complexity.GOAnnotation.ID(childComplexity), true

	case "GOAnnotation.publication":
		if e.complexity.GOAnnotation.Publication == nil {
			break
		}

		return e.complexity.GOAnnotation.Publication(childComplexity), true

	case "GOAnnotation.qualifier":
		if e.complexity.GOAnnotation.Qualifier == nil {
			break
		}

		return e.complexity.GOAnnotation.Qualifier(childComplexity), true

	case "GOAnnotation.type":
		if e.complexity.GOAnnotation.Type == nil {
			break
		}

		return e.complexity.GOAnnotation.Type(childComplexity), true

	case "GOAnnotation.with":
		if e.complexity.GOAnnotation.With == nil {
			break
		}

		return e.complexity.GOAnnotation.With(childComplexity), true

	case "Gene.id":
		if e.complexity.Gene.ID == nil {
			break
		}

		return e.complexity.Gene.ID(childComplexity), true

	case "Gene.name":
		if e.complexity.Gene.Name == nil {
			break
		}

		return e.complexity.Gene.Name(childComplexity), true

	case "GeneGeneralInfo.description":
		if e.complexity.GeneGeneralInfo.Description == nil {
			break
		}

		return e.complexity.GeneGeneralInfo.Description(childComplexity), true

	case "GeneGeneralInfo.gene_product":
		if e.complexity.GeneGeneralInfo.GeneProduct == nil {
			break
		}

		return e.complexity.GeneGeneralInfo.GeneProduct(childComplexity), true

	case "GeneGeneralInfo.id":
		if e.complexity.GeneGeneralInfo.ID == nil {
			break
		}

		return e.complexity.GeneGeneralInfo.ID(childComplexity), true

	case "GeneGeneralInfo.name_description":
		if e.complexity.GeneGeneralInfo.NameDescription == nil {
			break
		}

		return e.complexity.GeneGeneralInfo.NameDescription(childComplexity), true

	case "GeneGeneralInfo.synonyms":
		if e.complexity.GeneGeneralInfo.Synonyms == nil {
			break
		}

		return e.complexity.GeneGeneralInfo.Synonyms(childComplexity), true

	case "Identity.created_at":
		if e.complexity.Identity.CreatedAt == nil {
			break
		}

		return e.complexity.Identity.CreatedAt(childComplexity), true

	case "Identity.id":
		if e.complexity.Identity.ID == nil {
			break
		}

		return e.complexity.Identity.ID(childComplexity), true

	case "Identity.identifier":
		if e.complexity.Identity.Identifier == nil {
			break
		}

		return e.complexity.Identity.Identifier(childComplexity), true

	case "Identity.provider":
		if e.complexity.Identity.Provider == nil {
			break
		}

		return e.complexity.Identity.Provider(childComplexity), true

	case "Identity.updated_at":
		if e.complexity.Identity.UpdatedAt == nil {
			break
		}

		return e.complexity.Identity.UpdatedAt(childComplexity), true

	case "Identity.user_id":
		if e.complexity.Identity.UserID == nil {
			break
		}

		return e.complexity.Identity.UserID(childComplexity), true

	case "ImageFile.url":
		if e.complexity.ImageFile.URL == nil {
			break
		}

		return e.complexity.ImageFile.URL(childComplexity), true

	case "Logout.success":
		if e.complexity.Logout.Success == nil {
			break
		}

		return e.complexity.Logout.Success(childComplexity), true

	case "Mutation.createContent":
		if e.complexity.Mutation.CreateContent == nil {
			break
		}

		args, err := ec.field_Mutation_createContent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateContent(childComplexity, args["input"].(*models.CreateContentInput)), true

	case "Mutation.createOrder":
		if e.complexity.Mutation.CreateOrder == nil {
			break
		}

		args, err := ec.field_Mutation_createOrder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOrder(childComplexity, args["input"].(*models.CreateOrderInput)), true

	case "Mutation.createPermission":
		if e.complexity.Mutation.CreatePermission == nil {
			break
		}

		args, err := ec.field_Mutation_createPermission_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePermission(childComplexity, args["input"].(*models.CreatePermissionInput)), true

	case "Mutation.createPlasmid":
		if e.complexity.Mutation.CreatePlasmid == nil {
			break
		}

		args, err := ec.field_Mutation_createPlasmid_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePlasmid(childComplexity, args["input"].(*models.CreatePlasmidInput)), true

	case "Mutation.createRole":
		if e.complexity.Mutation.CreateRole == nil {
			break
		}

		args, err := ec.field_Mutation_createRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRole(childComplexity, args["input"].(*models.CreateRoleInput)), true

	case "Mutation.createRolePermissionRelationship":
		if e.complexity.Mutation.CreateRolePermissionRelationship == nil {
			break
		}

		args, err := ec.field_Mutation_createRolePermissionRelationship_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRolePermissionRelationship(childComplexity, args["roleId"].(string), args["permissionId"].(string)), true

	case "Mutation.createStrain":
		if e.complexity.Mutation.CreateStrain == nil {
			break
		}

		args, err := ec.field_Mutation_createStrain_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateStrain(childComplexity, args["input"].(*models.CreateStrainInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(*models.CreateUserInput)), true

	case "Mutation.createUserRoleRelationship":
		if e.complexity.Mutation.CreateUserRoleRelationship == nil {
			break
		}

		args, err := ec.field_Mutation_createUserRoleRelationship_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUserRoleRelationship(childComplexity, args["userId"].(string), args["roleId"].(string)), true

	case "Mutation.deleteContent":
		if e.complexity.Mutation.DeleteContent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteContent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteContent(childComplexity, args["id"].(string)), true

	case "Mutation.deletePermission":
		if e.complexity.Mutation.DeletePermission == nil {
			break
		}

		args, err := ec.field_Mutation_deletePermission_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePermission(childComplexity, args["id"].(string)), true

	case "Mutation.deleteRole":
		if e.complexity.Mutation.DeleteRole == nil {
			break
		}

		args, err := ec.field_Mutation_deleteRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRole(childComplexity, args["id"].(string)), true

	case "Mutation.deleteStock":
		if e.complexity.Mutation.DeleteStock == nil {
			break
		}

		args, err := ec.field_Mutation_deleteStock_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteStock(childComplexity, args["id"].(string)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(string)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(*models.LoginInput)), true

	case "Mutation.logout":
		if e.complexity.Mutation.Logout == nil {
			break
		}

		return e.complexity.Mutation.Logout(childComplexity), true

	case "Mutation.updateContent":
		if e.complexity.Mutation.UpdateContent == nil {
			break
		}

		args, err := ec.field_Mutation_updateContent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateContent(childComplexity, args["input"].(*models.UpdateContentInput)), true

	case "Mutation.updateOrder":
		if e.complexity.Mutation.UpdateOrder == nil {
			break
		}

		args, err := ec.field_Mutation_updateOrder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOrder(childComplexity, args["id"].(string), args["input"].(*models.UpdateOrderInput)), true

	case "Mutation.updatePermission":
		if e.complexity.Mutation.UpdatePermission == nil {
			break
		}

		args, err := ec.field_Mutation_updatePermission_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePermission(childComplexity, args["id"].(string), args["input"].(*models.UpdatePermissionInput)), true

	case "Mutation.updatePlasmid":
		if e.complexity.Mutation.UpdatePlasmid == nil {
			break
		}

		args, err := ec.field_Mutation_updatePlasmid_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePlasmid(childComplexity, args["id"].(string), args["input"].(*models.UpdatePlasmidInput)), true

	case "Mutation.updateRole":
		if e.complexity.Mutation.UpdateRole == nil {
			break
		}

		args, err := ec.field_Mutation_updateRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRole(childComplexity, args["id"].(string), args["input"].(*models.UpdateRoleInput)), true

	case "Mutation.updateStrain":
		if e.complexity.Mutation.UpdateStrain == nil {
			break
		}

		args, err := ec.field_Mutation_updateStrain_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateStrain(childComplexity, args["id"].(string), args["input"].(*models.UpdateStrainInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(string), args["input"].(*models.UpdateUserInput)), true

	case "Mutation.uploadFile":
		if e.complexity.Mutation.UploadFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadFile_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadFile(childComplexity, args["file"].(graphql.Upload)), true

	case "NumberOfPublicationsWithGene.num_pubs":
		if e.complexity.NumberOfPublicationsWithGene.NumPubs == nil {
			break
		}

		return e.complexity.NumberOfPublicationsWithGene.NumPubs(childComplexity), true

	case "NumberOfPublicationsWithGene.publications":
		if e.complexity.NumberOfPublicationsWithGene.Publications == nil {
			break
		}

		return e.complexity.NumberOfPublicationsWithGene.Publications(childComplexity), true

	case "Order.comments":
		if e.complexity.Order.Comments == nil {
			break
		}

		return e.complexity.Order.Comments(childComplexity), true

	case "Order.consumer":
		if e.complexity.Order.Consumer == nil {
			break
		}

		return e.complexity.Order.Consumer(childComplexity), true

	case "Order.courier":
		if e.complexity.Order.Courier == nil {
			break
		}

		return e.complexity.Order.Courier(childComplexity), true

	case "Order.courier_account":
		if e.complexity.Order.CourierAccount == nil {
			break
		}

		return e.complexity.Order.CourierAccount(childComplexity), true

	case "Order.created_at":
		if e.complexity.Order.CreatedAt == nil {
			break
		}

		return e.complexity.Order.CreatedAt(childComplexity), true

	case "Order.id":
		if e.complexity.Order.ID == nil {
			break
		}

		return e.complexity.Order.ID(childComplexity), true

	case "Order.items":
		if e.complexity.Order.Items == nil {
			break
		}

		return e.complexity.Order.Items(childComplexity), true

	case "Order.payer":
		if e.complexity.Order.Payer == nil {
			break
		}

		return e.complexity.Order.Payer(childComplexity), true

	case "Order.payment":
		if e.complexity.Order.Payment == nil {
			break
		}

		return e.complexity.Order.Payment(childComplexity), true

	case "Order.purchase_order_num":
		if e.complexity.Order.PurchaseOrderNum == nil {
			break
		}

		return e.complexity.Order.PurchaseOrderNum(childComplexity), true

	case "Order.purchaser":
		if e.complexity.Order.Purchaser == nil {
			break
		}

		return e.complexity.Order.Purchaser(childComplexity), true

	case "Order.status":
		if e.complexity.Order.Status == nil {
			break
		}

		return e.complexity.Order.Status(childComplexity), true

	case "Order.updated_at":
		if e.complexity.Order.UpdatedAt == nil {
			break
		}

		return e.complexity.Order.UpdatedAt(childComplexity), true

	case "OrderListWithCursor.limit":
		if e.complexity.OrderListWithCursor.Limit == nil {
			break
		}

		return e.complexity.OrderListWithCursor.Limit(childComplexity), true

	case "OrderListWithCursor.nextCursor":
		if e.complexity.OrderListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.OrderListWithCursor.NextCursor(childComplexity), true

	case "OrderListWithCursor.orders":
		if e.complexity.OrderListWithCursor.Orders == nil {
			break
		}

		return e.complexity.OrderListWithCursor.Orders(childComplexity), true

	case "OrderListWithCursor.previousCursor":
		if e.complexity.OrderListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.OrderListWithCursor.PreviousCursor(childComplexity), true

	case "OrderListWithCursor.totalCount":
		if e.complexity.OrderListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.OrderListWithCursor.TotalCount(childComplexity), true

	case "Organism.citations":
		if e.complexity.Organism.Citations == nil {
			break
		}

		return e.complexity.Organism.Citations(childComplexity), true

	case "Organism.downloads":
		if e.complexity.Organism.Downloads == nil {
			break
		}

		return e.complexity.Organism.Downloads(childComplexity), true

	case "Organism.scientific_name":
		if e.complexity.Organism.ScientificName == nil {
			break
		}

		return e.complexity.Organism.ScientificName(childComplexity), true

	case "Organism.taxon_id":
		if e.complexity.Organism.TaxonID == nil {
			break
		}

		return e.complexity.Organism.TaxonID(childComplexity), true

	case "Permission.created_at":
		if e.complexity.Permission.CreatedAt == nil {
			break
		}

		return e.complexity.Permission.CreatedAt(childComplexity), true

	case "Permission.description":
		if e.complexity.Permission.Description == nil {
			break
		}

		return e.complexity.Permission.Description(childComplexity), true

	case "Permission.id":
		if e.complexity.Permission.ID == nil {
			break
		}

		return e.complexity.Permission.ID(childComplexity), true

	case "Permission.permission":
		if e.complexity.Permission.Permission == nil {
			break
		}

		return e.complexity.Permission.Permission(childComplexity), true

	case "Permission.resource":
		if e.complexity.Permission.Resource == nil {
			break
		}

		return e.complexity.Permission.Resource(childComplexity), true

	case "Permission.updated_at":
		if e.complexity.Permission.UpdatedAt == nil {
			break
		}

		return e.complexity.Permission.UpdatedAt(childComplexity), true

	case "Phenotype.assay":
		if e.complexity.Phenotype.Assay == nil {
			break
		}

		return e.complexity.Phenotype.Assay(childComplexity), true

	case "Phenotype.environment":
		if e.complexity.Phenotype.Environment == nil {
			break
		}

		return e.complexity.Phenotype.Environment(childComplexity), true

	case "Phenotype.note":
		if e.complexity.Phenotype.Note == nil {
			break
		}

		return e.complexity.Phenotype.Note(childComplexity), true

	case "Phenotype.phenotype":
		if e.complexity.Phenotype.Phenotype == nil {
			break
		}

		return e.complexity.Phenotype.Phenotype(childComplexity), true

	case "Phenotype.publication":
		if e.complexity.Phenotype.Publication == nil {
			break
		}

		return e.complexity.Phenotype.Publication(childComplexity), true

	case "Plasmid.created_at":
		if e.complexity.Plasmid.CreatedAt == nil {
			break
		}

		return e.complexity.Plasmid.CreatedAt(childComplexity), true

	case "Plasmid.created_by":
		if e.complexity.Plasmid.CreatedBy == nil {
			break
		}

		return e.complexity.Plasmid.CreatedBy(childComplexity), true

	case "Plasmid.dbxrefs":
		if e.complexity.Plasmid.Dbxrefs == nil {
			break
		}

		return e.complexity.Plasmid.Dbxrefs(childComplexity), true

	case "Plasmid.depositor":
		if e.complexity.Plasmid.Depositor == nil {
			break
		}

		return e.complexity.Plasmid.Depositor(childComplexity), true

	case "Plasmid.editable_summary":
		if e.complexity.Plasmid.EditableSummary == nil {
			break
		}

		return e.complexity.Plasmid.EditableSummary(childComplexity), true

	case "Plasmid.genbank_accession":
		if e.complexity.Plasmid.GenbankAccession == nil {
			break
		}

		return e.complexity.Plasmid.GenbankAccession(childComplexity), true

	case "Plasmid.genes":
		if e.complexity.Plasmid.Genes == nil {
			break
		}

		return e.complexity.Plasmid.Genes(childComplexity), true

	case "Plasmid.id":
		if e.complexity.Plasmid.ID == nil {
			break
		}

		return e.complexity.Plasmid.ID(childComplexity), true

	case "Plasmid.image_map":
		if e.complexity.Plasmid.ImageMap == nil {
			break
		}

		return e.complexity.Plasmid.ImageMap(childComplexity), true

	case "Plasmid.in_stock":
		if e.complexity.Plasmid.InStock == nil {
			break
		}

		return e.complexity.Plasmid.InStock(childComplexity), true

	case "Plasmid.keywords":
		if e.complexity.Plasmid.Keywords == nil {
			break
		}

		return e.complexity.Plasmid.Keywords(childComplexity), true

	case "Plasmid.name":
		if e.complexity.Plasmid.Name == nil {
			break
		}

		return e.complexity.Plasmid.Name(childComplexity), true

	case "Plasmid.publications":
		if e.complexity.Plasmid.Publications == nil {
			break
		}

		return e.complexity.Plasmid.Publications(childComplexity), true

	case "Plasmid.sequence":
		if e.complexity.Plasmid.Sequence == nil {
			break
		}

		return e.complexity.Plasmid.Sequence(childComplexity), true

	case "Plasmid.summary":
		if e.complexity.Plasmid.Summary == nil {
			break
		}

		return e.complexity.Plasmid.Summary(childComplexity), true

	case "Plasmid.updated_at":
		if e.complexity.Plasmid.UpdatedAt == nil {
			break
		}

		return e.complexity.Plasmid.UpdatedAt(childComplexity), true

	case "Plasmid.updated_by":
		if e.complexity.Plasmid.UpdatedBy == nil {
			break
		}

		return e.complexity.Plasmid.UpdatedBy(childComplexity), true

	case "PlasmidListWithCursor.limit":
		if e.complexity.PlasmidListWithCursor.Limit == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.Limit(childComplexity), true

	case "PlasmidListWithCursor.nextCursor":
		if e.complexity.PlasmidListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.NextCursor(childComplexity), true

	case "PlasmidListWithCursor.plasmids":
		if e.complexity.PlasmidListWithCursor.Plasmids == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.Plasmids(childComplexity), true

	case "PlasmidListWithCursor.previousCursor":
		if e.complexity.PlasmidListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.PreviousCursor(childComplexity), true

	case "PlasmidListWithCursor.totalCount":
		if e.complexity.PlasmidListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.PlasmidListWithCursor.TotalCount(childComplexity), true

	case "Publication.abstract":
		if e.complexity.Publication.Abstract == nil {
			break
		}

		return e.complexity.Publication.Abstract(childComplexity), true

	case "Publication.authors":
		if e.complexity.Publication.Authors == nil {
			break
		}

		return e.complexity.Publication.Authors(childComplexity), true

	case "Publication.doi":
		if e.complexity.Publication.Doi == nil {
			break
		}

		return e.complexity.Publication.Doi(childComplexity), true

	case "Publication.id":
		if e.complexity.Publication.ID == nil {
			break
		}

		return e.complexity.Publication.ID(childComplexity), true

	case "Publication.issn":
		if e.complexity.Publication.Issn == nil {
			break
		}

		return e.complexity.Publication.Issn(childComplexity), true

	case "Publication.issue":
		if e.complexity.Publication.Issue == nil {
			break
		}

		return e.complexity.Publication.Issue(childComplexity), true

	case "Publication.journal":
		if e.complexity.Publication.Journal == nil {
			break
		}

		return e.complexity.Publication.Journal(childComplexity), true

	case "Publication.pages":
		if e.complexity.Publication.Pages == nil {
			break
		}

		return e.complexity.Publication.Pages(childComplexity), true

	case "Publication.pub_date":
		if e.complexity.Publication.PubDate == nil {
			break
		}

		return e.complexity.Publication.PubDate(childComplexity), true

	case "Publication.pub_type":
		if e.complexity.Publication.PubType == nil {
			break
		}

		return e.complexity.Publication.PubType(childComplexity), true

	case "Publication.source":
		if e.complexity.Publication.Source == nil {
			break
		}

		return e.complexity.Publication.Source(childComplexity), true

	case "Publication.status":
		if e.complexity.Publication.Status == nil {
			break
		}

		return e.complexity.Publication.Status(childComplexity), true

	case "Publication.title":
		if e.complexity.Publication.Title == nil {
			break
		}

		return e.complexity.Publication.Title(childComplexity), true

	case "Publication.volume":
		if e.complexity.Publication.Volume == nil {
			break
		}

		return e.complexity.Publication.Volume(childComplexity), true

	case "PublicationWithGene.abstract":
		if e.complexity.PublicationWithGene.Abstract == nil {
			break
		}

		return e.complexity.PublicationWithGene.Abstract(childComplexity), true

	case "PublicationWithGene.authors":
		if e.complexity.PublicationWithGene.Authors == nil {
			break
		}

		return e.complexity.PublicationWithGene.Authors(childComplexity), true

	case "PublicationWithGene.doi":
		if e.complexity.PublicationWithGene.Doi == nil {
			break
		}

		return e.complexity.PublicationWithGene.Doi(childComplexity), true

	case "PublicationWithGene.id":
		if e.complexity.PublicationWithGene.ID == nil {
			break
		}

		return e.complexity.PublicationWithGene.ID(childComplexity), true

	case "PublicationWithGene.issn":
		if e.complexity.PublicationWithGene.Issn == nil {
			break
		}

		return e.complexity.PublicationWithGene.Issn(childComplexity), true

	case "PublicationWithGene.issue":
		if e.complexity.PublicationWithGene.Issue == nil {
			break
		}

		return e.complexity.PublicationWithGene.Issue(childComplexity), true

	case "PublicationWithGene.journal":
		if e.complexity.PublicationWithGene.Journal == nil {
			break
		}

		return e.complexity.PublicationWithGene.Journal(childComplexity), true

	case "PublicationWithGene.pages":
		if e.complexity.PublicationWithGene.Pages == nil {
			break
		}

		return e.complexity.PublicationWithGene.Pages(childComplexity), true

	case "PublicationWithGene.pub_date":
		if e.complexity.PublicationWithGene.PubDate == nil {
			break
		}

		return e.complexity.PublicationWithGene.PubDate(childComplexity), true

	case "PublicationWithGene.pub_type":
		if e.complexity.PublicationWithGene.PubType == nil {
			break
		}

		return e.complexity.PublicationWithGene.PubType(childComplexity), true

	case "PublicationWithGene.related_genes":
		if e.complexity.PublicationWithGene.RelatedGenes == nil {
			break
		}

		return e.complexity.PublicationWithGene.RelatedGenes(childComplexity), true

	case "PublicationWithGene.source":
		if e.complexity.PublicationWithGene.Source == nil {
			break
		}

		return e.complexity.PublicationWithGene.Source(childComplexity), true

	case "PublicationWithGene.status":
		if e.complexity.PublicationWithGene.Status == nil {
			break
		}

		return e.complexity.PublicationWithGene.Status(childComplexity), true

	case "PublicationWithGene.title":
		if e.complexity.PublicationWithGene.Title == nil {
			break
		}

		return e.complexity.PublicationWithGene.Title(childComplexity), true

	case "PublicationWithGene.volume":
		if e.complexity.PublicationWithGene.Volume == nil {
			break
		}

		return e.complexity.PublicationWithGene.Volume(childComplexity), true

	case "Query.content":
		if e.complexity.Query.Content == nil {
			break
		}

		args, err := ec.field_Query_content_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Content(childComplexity, args["id"].(string)), true

	case "Query.contentBySlug":
		if e.complexity.Query.ContentBySlug == nil {
			break
		}

		args, err := ec.field_Query_contentBySlug_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ContentBySlug(childComplexity, args["slug"].(string)), true

	case "Query.geneGeneralInformation":
		if e.complexity.Query.GeneGeneralInformation == nil {
			break
		}

		args, err := ec.field_Query_geneGeneralInformation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GeneGeneralInformation(childComplexity, args["gene"].(string)), true

	case "Query.geneOntologyAnnotation":
		if e.complexity.Query.GeneOntologyAnnotation == nil {
			break
		}

		args, err := ec.field_Query_geneOntologyAnnotation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GeneOntologyAnnotation(childComplexity, args["gene"].(string)), true

	case "Query.listContentByNamespace":
		if e.complexity.Query.ListContentByNamespace == nil {
			break
		}

		args, err := ec.field_Query_listContentByNamespace_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListContentByNamespace(childComplexity, args["namespace"].(string)), true

	case "Query.listOrders":
		if e.complexity.Query.ListOrders == nil {
			break
		}

		args, err := ec.field_Query_listOrders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListOrders(childComplexity, args["cursor"].(*int), args["limit"].(*int), args["filter"].(*string)), true

	case "Query.listOrganisms":
		if e.complexity.Query.ListOrganisms == nil {
			break
		}

		return e.complexity.Query.ListOrganisms(childComplexity), true

	case "Query.listPermissions":
		if e.complexity.Query.ListPermissions == nil {
			break
		}

		return e.complexity.Query.ListPermissions(childComplexity), true

	case "Query.listPlasmids":
		if e.complexity.Query.ListPlasmids == nil {
			break
		}

		args, err := ec.field_Query_listPlasmids_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPlasmids(childComplexity, args["cursor"].(*int), args["limit"].(*int), args["filter"].(*string)), true

	case "Query.listPlasmidsWithAnnotation":
		if e.complexity.Query.ListPlasmidsWithAnnotation == nil {
			break
		}

		args, err := ec.field_Query_listPlasmidsWithAnnotation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPlasmidsWithAnnotation(childComplexity, args["cursor"].(*int), args["limit"].(*int), args["type"].(string), args["annotation"].(string)), true

	case "Query.listPublicationsWithGene":
		if e.complexity.Query.ListPublicationsWithGene == nil {
			break
		}

		args, err := ec.field_Query_listPublicationsWithGene_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPublicationsWithGene(childComplexity, args["gene"].(string)), true

	case "Query.listRecentPlasmids":
		if e.complexity.Query.ListRecentPlasmids == nil {
			break
		}

		args, err := ec.field_Query_listRecentPlasmids_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListRecentPlasmids(childComplexity, args["limit"].(int)), true

	case "Query.listRecentPublications":
		if e.complexity.Query.ListRecentPublications == nil {
			break
		}

		args, err := ec.field_Query_listRecentPublications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListRecentPublications(childComplexity, args["limit"].(int)), true

	case "Query.listRecentStrains":
		if e.complexity.Query.ListRecentStrains == nil {
			break
		}

		args, err := ec.field_Query_listRecentStrains_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListRecentStrains(childComplexity, args["limit"].(int)), true

	case "Query.listRoles":
		if e.complexity.Query.ListRoles == nil {
			break
		}

		return e.complexity.Query.ListRoles(childComplexity), true

	case "Query.listStrains":
		if e.complexity.Query.ListStrains == nil {
			break
		}

		args, err := ec.field_Query_listStrains_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListStrains(childComplexity, args["cursor"].(*int), args["limit"].(*int), args["filter"].(*models.StrainListFilter)), true

	case "Query.listStrainsWithAnnotation":
		if e.complexity.Query.ListStrainsWithAnnotation == nil {
			break
		}

		args, err := ec.field_Query_listStrainsWithAnnotation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListStrainsWithAnnotation(childComplexity, args["cursor"].(*int), args["limit"].(*int), args["type"].(string), args["annotation"].(string)), true

	case "Query.listStrainsWithGene":
		if e.complexity.Query.ListStrainsWithGene == nil {
			break
		}

		args, err := ec.field_Query_listStrainsWithGene_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListStrainsWithGene(childComplexity, args["gene"].(string)), true

	case "Query.listUsers":
		if e.complexity.Query.ListUsers == nil {
			break
		}

		args, err := ec.field_Query_listUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListUsers(childComplexity, args["pagenum"].(string), args["pagesize"].(string), args["filter"].(string)), true

	case "Query.order":
		if e.complexity.Query.Order == nil {
			break
		}

		args, err := ec.field_Query_order_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Order(childComplexity, args["id"].(string)), true

	case "Query.organism":
		if e.complexity.Query.Organism == nil {
			break
		}

		args, err := ec.field_Query_organism_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Organism(childComplexity, args["taxon_id"].(string)), true

	case "Query.permission":
		if e.complexity.Query.Permission == nil {
			break
		}

		args, err := ec.field_Query_permission_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Permission(childComplexity, args["id"].(string)), true

	case "Query.plasmid":
		if e.complexity.Query.Plasmid == nil {
			break
		}

		args, err := ec.field_Query_plasmid_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Plasmid(childComplexity, args["id"].(string)), true

	case "Query.publication":
		if e.complexity.Query.Publication == nil {
			break
		}

		args, err := ec.field_Query_publication_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Publication(childComplexity, args["id"].(string)), true

	case "Query.role":
		if e.complexity.Query.Role == nil {
			break
		}

		args, err := ec.field_Query_role_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Role(childComplexity, args["id"].(string)), true

	case "Query.strain":
		if e.complexity.Query.Strain == nil {
			break
		}

		args, err := ec.field_Query_strain_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Strain(childComplexity, args["id"].(string)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(string)), true

	case "Query.userByEmail":
		if e.complexity.Query.UserByEmail == nil {
			break
		}

		args, err := ec.field_Query_userByEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByEmail(childComplexity, args["email"].(string)), true

	case "Role.created_at":
		if e.complexity.Role.CreatedAt == nil {
			break
		}

		return e.complexity.Role.CreatedAt(childComplexity), true

	case "Role.description":
		if e.complexity.Role.Description == nil {
			break
		}

		return e.complexity.Role.Description(childComplexity), true

	case "Role.id":
		if e.complexity.Role.ID == nil {
			break
		}

		return e.complexity.Role.ID(childComplexity), true

	case "Role.permissions":
		if e.complexity.Role.Permissions == nil {
			break
		}

		return e.complexity.Role.Permissions(childComplexity), true

	case "Role.role":
		if e.complexity.Role.Role == nil {
			break
		}

		return e.complexity.Role.Role(childComplexity), true

	case "Role.updated_at":
		if e.complexity.Role.UpdatedAt == nil {
			break
		}

		return e.complexity.Role.UpdatedAt(childComplexity), true

	case "Strain.characteristics":
		if e.complexity.Strain.Characteristics == nil {
			break
		}

		return e.complexity.Strain.Characteristics(childComplexity), true

	case "Strain.created_at":
		if e.complexity.Strain.CreatedAt == nil {
			break
		}

		return e.complexity.Strain.CreatedAt(childComplexity), true

	case "Strain.created_by":
		if e.complexity.Strain.CreatedBy == nil {
			break
		}

		return e.complexity.Strain.CreatedBy(childComplexity), true

	case "Strain.dbxrefs":
		if e.complexity.Strain.Dbxrefs == nil {
			break
		}

		return e.complexity.Strain.Dbxrefs(childComplexity), true

	case "Strain.depositor":
		if e.complexity.Strain.Depositor == nil {
			break
		}

		return e.complexity.Strain.Depositor(childComplexity), true

	case "Strain.editable_summary":
		if e.complexity.Strain.EditableSummary == nil {
			break
		}

		return e.complexity.Strain.EditableSummary(childComplexity), true

	case "Strain.genes":
		if e.complexity.Strain.Genes == nil {
			break
		}

		return e.complexity.Strain.Genes(childComplexity), true

	case "Strain.genetic_modification":
		if e.complexity.Strain.GeneticModification == nil {
			break
		}

		return e.complexity.Strain.GeneticModification(childComplexity), true

	case "Strain.genotypes":
		if e.complexity.Strain.Genotypes == nil {
			break
		}

		return e.complexity.Strain.Genotypes(childComplexity), true

	case "Strain.id":
		if e.complexity.Strain.ID == nil {
			break
		}

		return e.complexity.Strain.ID(childComplexity), true

	case "Strain.in_stock":
		if e.complexity.Strain.InStock == nil {
			break
		}

		return e.complexity.Strain.InStock(childComplexity), true

	case "Strain.label":
		if e.complexity.Strain.Label == nil {
			break
		}

		return e.complexity.Strain.Label(childComplexity), true

	case "Strain.mutagenesis_method":
		if e.complexity.Strain.MutagenesisMethod == nil {
			break
		}

		return e.complexity.Strain.MutagenesisMethod(childComplexity), true

	case "Strain.names":
		if e.complexity.Strain.Names == nil {
			break
		}

		return e.complexity.Strain.Names(childComplexity), true

	case "Strain.parent":
		if e.complexity.Strain.Parent == nil {
			break
		}

		return e.complexity.Strain.Parent(childComplexity), true

	case "Strain.phenotypes":
		if e.complexity.Strain.Phenotypes == nil {
			break
		}

		return e.complexity.Strain.Phenotypes(childComplexity), true

	case "Strain.plasmid":
		if e.complexity.Strain.Plasmid == nil {
			break
		}

		return e.complexity.Strain.Plasmid(childComplexity), true

	case "Strain.publications":
		if e.complexity.Strain.Publications == nil {
			break
		}

		return e.complexity.Strain.Publications(childComplexity), true

	case "Strain.species":
		if e.complexity.Strain.Species == nil {
			break
		}

		return e.complexity.Strain.Species(childComplexity), true

	case "Strain.summary":
		if e.complexity.Strain.Summary == nil {
			break
		}

		return e.complexity.Strain.Summary(childComplexity), true

	case "Strain.systematic_name":
		if e.complexity.Strain.SystematicName == nil {
			break
		}

		return e.complexity.Strain.SystematicName(childComplexity), true

	case "Strain.updated_at":
		if e.complexity.Strain.UpdatedAt == nil {
			break
		}

		return e.complexity.Strain.UpdatedAt(childComplexity), true

	case "Strain.updated_by":
		if e.complexity.Strain.UpdatedBy == nil {
			break
		}

		return e.complexity.Strain.UpdatedBy(childComplexity), true

	case "StrainListWithCursor.limit":
		if e.complexity.StrainListWithCursor.Limit == nil {
			break
		}

		return e.complexity.StrainListWithCursor.Limit(childComplexity), true

	case "StrainListWithCursor.nextCursor":
		if e.complexity.StrainListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.StrainListWithCursor.NextCursor(childComplexity), true

	case "StrainListWithCursor.previousCursor":
		if e.complexity.StrainListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.StrainListWithCursor.PreviousCursor(childComplexity), true

	case "StrainListWithCursor.strains":
		if e.complexity.StrainListWithCursor.Strains == nil {
			break
		}

		return e.complexity.StrainListWithCursor.Strains(childComplexity), true

	case "StrainListWithCursor.totalCount":
		if e.complexity.StrainListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.StrainListWithCursor.TotalCount(childComplexity), true

	case "User.city":
		if e.complexity.User.City == nil {
			break
		}

		return e.complexity.User.City(childComplexity), true

	case "User.country":
		if e.complexity.User.Country == nil {
			break
		}

		return e.complexity.User.Country(childComplexity), true

	case "User.created_at":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.first_address":
		if e.complexity.User.FirstAddress == nil {
			break
		}

		return e.complexity.User.FirstAddress(childComplexity), true

	case "User.first_name":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.group_name":
		if e.complexity.User.GroupName == nil {
			break
		}

		return e.complexity.User.GroupName(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.is_active":
		if e.complexity.User.IsActive == nil {
			break
		}

		return e.complexity.User.IsActive(childComplexity), true

	case "User.last_name":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.organization":
		if e.complexity.User.Organization == nil {
			break
		}

		return e.complexity.User.Organization(childComplexity), true

	case "User.phone":
		if e.complexity.User.Phone == nil {
			break
		}

		return e.complexity.User.Phone(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "User.second_address":
		if e.complexity.User.SecondAddress == nil {
			break
		}

		return e.complexity.User.SecondAddress(childComplexity), true

	case "User.state":
		if e.complexity.User.State == nil {
			break
		}

		return e.complexity.User.State(childComplexity), true

	case "User.updated_at":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.zipcode":
		if e.complexity.User.Zipcode == nil {
			break
		}

		return e.complexity.User.Zipcode(childComplexity), true

	case "UserList.pageNum":
		if e.complexity.UserList.PageNum == nil {
			break
		}

		return e.complexity.UserList.PageNum(childComplexity), true

	case "UserList.pageSize":
		if e.complexity.UserList.PageSize == nil {
			break
		}

		return e.complexity.UserList.PageSize(childComplexity), true

	case "UserList.totalCount":
		if e.complexity.UserList.TotalCount == nil {
			break
		}

		return e.complexity.UserList.TotalCount(childComplexity), true

	case "UserList.users":
		if e.complexity.UserList.Users == nil {
			break
		}

		return e.complexity.UserList.Users(childComplexity), true

	case "With.db":
		if e.complexity.With.Db == nil {
			break
		}

		return e.complexity.With.Db(childComplexity), true

	case "With.id":
		if e.complexity.With.ID == nil {
			break
		}

		return e.complexity.With.ID(childComplexity), true

	case "With.name":
		if e.complexity.With.Name == nil {
			break
		}

		return e.complexity.With.Name(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateContentInput,
		ec.unmarshalInputCreateOrderInput,
		ec.unmarshalInputCreatePermissionInput,
		ec.unmarshalInputCreatePlasmidInput,
		ec.unmarshalInputCreateRoleInput,
		ec.unmarshalInputCreateStrainInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputFileToUpload,
		ec.unmarshalInputLoginInput,
		ec.unmarshalInputStrainListFilter,
		ec.unmarshalInputUpdateContentInput,
		ec.unmarshalInputUpdateOrderInput,
		ec.unmarshalInputUpdatePermissionInput,
		ec.unmarshalInputUpdatePlasmidInput,
		ec.unmarshalInputUpdateRoleInput,
		ec.unmarshalInputUpdateStrainInput,
		ec.unmarshalInputUpdateUserInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../api/src/schema/auth.graphql", Input: `input LoginInput {
  client_id: String!
  state: String!
  code: String!
  scopes: String!
  provider: String!
  redirect_url: String!
}

type Identity {
  id: ID!
  identifier: String!
  provider: String!
  user_id: ID!
  created_at: Timestamp!
  updated_at: Timestamp!
}

type Auth {
  token: String!
  user: User!
  identity: Identity!
}

type Logout {
  success: Boolean!
}
`, BuiltIn: false},
	{Name: "../../../api/src/schema/content.graphql", Input: `type Content {
  id: ID!
  name: String!
  slug: String!
  created_by: User!
  updated_by: User!
  created_at: Timestamp!
  updated_at: Timestamp!
  content: String!
  namespace: String!
}

input CreateContentInput {
  name: String!
  created_by: String!
  content: String!
  namespace: String!
}

input UpdateContentInput {
  id: ID!
  updated_by: String!
  content: String!
}

type DeleteContent {
  success: Boolean!
}`, BuiltIn: false},
	{Name: "../../../api/src/schema/download.graphql", Input: `type Organism {
  taxon_id: String!
  scientific_name: String!
  citations: [Citation!]!
  downloads: [Download!]!
}

type Citation {
  authors: String!
  title: String!
  journal: String!
  pubmed_id: String!
}

type Download {
  title: String!
  items: [DownloadItem!]!
}

type DownloadItem {
  title: String!
  url: String!
}
`, BuiltIn: false},
	{Name: "../../../api/src/schema/gene.graphql", Input: `type Gene {
  id: String!
  name: String!
}

type GOAnnotation {
  id: String!
  type: String!
  date: String!
  evidence_code: String!
  go_term: String!
  qualifier: String!
  publication: String!
  with: [With!]
  extensions: [Extension!]
  assigned_by: String!
}

type With {
  id: String!
  db: String!
  name: String!
}

type Extension {
  id: String!
  db: String!
  relation: String!
  name: String!
}

type GeneGeneralInfo {
  id: String!
  name_description: [String]!
  gene_product: String
  synonyms: [String]!
  description: String
}
`, BuiltIn: false},
	{Name: "../../../api/src/schema/mutation.graphql", Input: `type Mutation {
  # Auth mutations
  login(input: LoginInput): Auth
  logout: Logout
  # Content mutations
  createContent(input: CreateContentInput): Content
  updateContent(input: UpdateContentInput): Content
  deleteContent(id: ID!): DeleteContent
  # Order mutations
  createOrder(input: CreateOrderInput): Order
  updateOrder(id: ID!, input: UpdateOrderInput): Order
  # Stock mutations
  createStrain(input: CreateStrainInput): Strain
  createPlasmid(input: CreatePlasmidInput): Plasmid
  updateStrain(id: ID!, input: UpdateStrainInput): Strain
  updatePlasmid(id: ID!, input: UpdatePlasmidInput): Plasmid
  deleteStock(id: ID!): DeleteStock
  # User mutations
  createUser(input: CreateUserInput): User
  createUserRoleRelationship(userId: ID!, roleId: ID!): User
  updateUser(id: ID!, input: UpdateUserInput): User
  deleteUser(id: ID!): DeleteUser
  createRole(input: CreateRoleInput): Role
  createRolePermissionRelationship(roleId: ID!, permissionId: ID!): Role
  updateRole(id: ID!, input: UpdateRoleInput): Role
  deleteRole(id: ID!): DeleteRole
  createPermission(input: CreatePermissionInput): Permission
  updatePermission(id: ID!, input: UpdatePermissionInput): Permission
  deletePermission(id: ID!): DeletePermission
  uploadFile(file: Upload! ): ImageFile!
}
`, BuiltIn: false},
	{Name: "../../../api/src/schema/order.graphql", Input: `type Order {
  id: ID!
  created_at: Timestamp!
  updated_at: Timestamp!
  courier: String
  courier_account: String
  comments: String
  payment: String
  purchase_order_num: String
  status: StatusEnum
  consumer: User
  payer: User
  purchaser: User
  items: [Stock!]
}

type OrderListWithCursor {
  orders: [Order!]!
  nextCursor: Int!
  previousCursor: Int!
  limit: Int
  totalCount: Int!
}

enum StatusEnum {
  IN_PREPARATION
  GROWING
  CANCELLED
  SHIPPED
}

input CreateOrderInput {
  courier: String!
  courier_account: String!
  comments: String
  payment: String!
  purchase_order_num: String
  status: StatusEnum!
  consumer: String!
  payer: String!
  purchaser: String!
  items: [String!]!
}

input UpdateOrderInput {
  courier: String
  courier_account: String
  comments: String
  payment: String
  purchase_order_num: String
  status: StatusEnum
  items: [String!]
}
`, BuiltIn: false},
	{Name: "../../../api/src/schema/publication.graphql", Input: `interface BasePublication {
  id: ID!
  doi: String
  title: String!
  abstract: String!
  journal: String!
  pub_date: Timestamp
  volume: String
  pages: String
  issn: String
  pub_type: String!
  source: String!
  issue: String
  status: String
  authors: [Author!]!
}

type Publication implements BasePublication {
  id: ID!
  doi: String
  title: String!
  abstract: String!
  journal: String!
  pub_date: Timestamp
  volume: String
  pages: String
  issn: String
  pub_type: String!
  source: String!
  issue: String
  status: String
  authors: [Author!]!
}

type PublicationWithGene implements BasePublication {
  related_genes: [Gene!]!
  id: ID!
  doi: String
  title: String!
  abstract: String!
  journal: String!
  pub_date: Timestamp
  volume: String
  pages: String
  issn: String
  pub_type: String!
  source: String!
  issue: String
  status: String
  authors: [Author!]!
}

type NumberOfPublicationsWithGene {
  num_pubs: Int!
  publications: [PublicationWithGene!]!
}

type Author {
  last_name: String!
  first_name: String
  initials: String
  rank: String
}

#type PublicationQuery {
#  listPublications: [Publication!]!
#}

# type PublicationListWithCursor {
#   publications: [Publication!]!
#   nextCursor: ID!
#   previousCursor: ID!
#   limit: Int
#   totalCount: Int!
# }

# input CreatePublicationInput {
#   doi: String
#   title: String
#   abstract: String
#   journal: String
#   pub_date: Timestamp
#   volume: String
#   pages: String
#   issn: String
#   pub_type: String
#   source: String
#   issue: String
#   status: String
#   authors: [CreateAuthorInput]
# }

# input CreateAuthorInput {
#   last_name: String
#   first_name: String
#   initials: String
#   rank: String
# }

# input UpdatePublicationInput {
#   pub_date: String
#   volume: String
#   pages: String
#   pub_type: String
#   source: String
#   status: String
#   authors: [UpdateAuthorInput]
# }

# input UpdateAuthorInput {
#   last_name: String
#   first_name: String
#   initials: String
#   rank: String
# }

# type DeletePublication {
#   success: Boolean!
# }
`, BuiltIn: false},
	{Name: "../../../api/src/schema/query.graphql", Input: `type Query {
  # Gene queries
  geneOntologyAnnotation(gene: String!): [GOAnnotation!]
  geneGeneralInformation(gene: String!): GeneGeneralInfo
  # Content queries
  content(id: ID!): Content
  contentBySlug(slug: String!): Content
  listContentByNamespace(namespace: String!): [Content!]!
  # Download page queries
  organism(taxon_id: String!): Organism
  listOrganisms: [Organism!]
  # Order queries
  order(id: ID!): Order
  listOrders(cursor: Int, limit: Int, filter: String): OrderListWithCursor
  # Publication queries
  publication(id: ID!): Publication
  # List publication query that is by default is sorted by publication
  # date in descendent order
  listRecentPublications(limit: Int!): [Publication!]
  listPublicationsWithGene(gene: String!): [PublicationWithGene!]!
  # Stock queries
  plasmid(id: ID!): Plasmid
  strain(id: ID!): Strain
  listStrainsWithGene(gene: String!): [Strain!]
  listStrains(
    cursor: Int
    limit: Int
    filter: StrainListFilter
  ): StrainListWithCursor
  listPlasmids(cursor: Int, limit: Int, filter: String): PlasmidListWithCursor
  listStrainsWithAnnotation(
    cursor: Int
    limit: Int
    type: String!
    annotation: String!
  ): StrainListWithCursor
  listPlasmidsWithAnnotation(
    cursor: Int
    limit: Int
    type: String!
    annotation: String!
  ): PlasmidListWithCursor
  # List plasmid query that is by default is sorted by plasmid
  # date in descendent order
  listRecentPlasmids(limit: Int!): [Plasmid!]
  # List strain query that is by default is sorted by strain
  # date in descendent order
  listRecentStrains(limit: Int!): [Strain!]
  # User queries
  user(id: ID!): User
  userByEmail(email: String!): User
  listUsers(pagenum: String!, pagesize: String!, filter: String!): UserList
  role(id: ID!): Role
  listRoles: [Role!]
  permission(id: ID!): Permission
  listPermissions: [Permission!]
}
`, BuiltIn: false},
	{Name: "../../../api/src/schema/scalar.graphql", Input: `scalar Timestamp
`, BuiltIn: false},
	{Name: "../../../api/src/schema/stock.graphql", Input: `interface Stock {
  id: ID!
  created_at: Timestamp!
  updated_at: Timestamp!
  created_by: User!
  updated_by: User!
  summary: String
  editable_summary: String
  depositor: User!
  genes: [Gene!]
  dbxrefs: [String!]
  publications: [Publication!]
  in_stock: Boolean!
}

type Strain implements Stock {
  id: ID!
  created_at: Timestamp!
  updated_at: Timestamp!
  created_by: User!
  updated_by: User!
  summary: String
  editable_summary: String
  depositor: User!
  genes: [Gene!]
  dbxrefs: [String!]
  publications: [Publication!]
  # from strain_properties
  systematic_name: String!
  label: String!
  species: String!
  plasmid: String # update to Plasmid later?
  parent: Strain
  names: [String!]
  # new additions
  in_stock: Boolean!
  phenotypes: [Phenotype!]
  genetic_modification: String
  mutagenesis_method: String
  characteristics: [String!]
  genotypes: [String!]
}

type Plasmid implements Stock {
  id: ID!
  created_at: Timestamp!
  updated_at: Timestamp!
  created_by: User!
  updated_by: User!
  summary: String # same as description field?
  editable_summary: String
  depositor: User!
  genes: [Gene!]
  dbxrefs: [String!]
  publications: [Publication!]
  name: String!
  # from plasmid_properties
  image_map: String
  sequence: String
  # new additions
  in_stock: Boolean!
  keywords: [String!]
  genbank_accession: String
}

type Phenotype {
  phenotype: String!
  note: String
  assay: String
  environment: String
  publication: Publication
}

type StrainListWithCursor {
  strains: [Strain!]!
  nextCursor: Int!
  previousCursor: Int!
  limit: Int
  totalCount: Int!
}

type PlasmidListWithCursor {
  plasmids: [Plasmid!]!
  nextCursor: Int!
  previousCursor: Int!
  limit: Int
  totalCount: Int!
}

type DeleteStock {
  success: Boolean!
}

input CreateStrainInput {
  created_by: String!
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String!]
  dbxrefs: [String!]
  publications: [String!]
  # from strain_properties
  systematic_name: String!
  label: String!
  species: String!
  plasmid: String
  parent: String
  names: [String!]
  # new additions
  in_stock: Boolean!
  phenotypes: [String!]
  genetic_modification: String
  mutagenesis_method: String
  characteristics: [String!]
  genotypes: [String!]
}

input CreatePlasmidInput {
  created_by: String!
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String!]
  dbxrefs: [String!]
  publications: [String!]
  name: String!
  # from plasmid_properties
  image_map: String
  sequence: String
  # new additions
  in_stock: Boolean!
  keywords: [String!]
  genbank_accession: String
}

input UpdateStrainInput {
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String!]
  dbxrefs: [String!]
  publications: [String!]
  # from strain_properties
  systematic_name: String
  label: String
  species: String
  plasmid: String
  parent: String
  names: [String!]
  # new additions
  in_stock: Boolean
  phenotypes: [String!]
  genetic_modification: String
  mutagenesis_method: String
  characteristics: [String!]
  genotypes: [String!]
}

input UpdatePlasmidInput {
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String!]
  dbxrefs: [String!]
  publications: [String!]
  name: String
  # from plasmid_properties
  image_map: String
  sequence: String
  # new additions
  in_stock: Boolean
  keywords: [String!]
  genbank_accession: String
}

enum StrainType {
  ALL 
  REGULAR 
  GWDI 
  BACTERIAL
}

input StrainListFilter {
  label: String
  summary: String
  id: ID
  in_stock: Boolean
  strain_type: StrainType!
}
`, BuiltIn: false},
	{Name: "../../../api/src/schema/upload.graphql", Input: `"The ` + "`" + `Upload` + "`" + ` scalar type represents a multipart file upload."
scalar Upload

"The ` + "`" + `ImageFile` + "`" + ` type, represents the response of uploading an image file."
type ImageFile {
    url: String!
}

"The ` + "`" + `UploadFile` + "`" + ` type, represents the request for uploading a image file with a certain payload."
input FileToUpload {
    id: Int!
    file: Upload!
}
`, BuiltIn: false},
	{Name: "../../../api/src/schema/user.graphql", Input: `type Permission {
  id: ID!
  permission: String!
  description: String!
  created_at: Timestamp!
  updated_at: Timestamp!
  resource: String
}

type Role {
  id: ID!
  role: String!
  description: String!
  created_at: Timestamp!
  updated_at: Timestamp!
  permissions: [Permission!]
}

type User {
  id: ID!
  first_name: String!
  last_name: String!
  email: String!
  organization: String
  group_name: String
  first_address: String
  second_address: String
  city: String
  state: String
  zipcode: String
  country: String
  phone: String
  is_active: Boolean!
  created_at: Timestamp!
  updated_at: Timestamp!
  roles: [Role!]
}

type UserList {
  users: [User!]!
  pageNum: String
  pageSize: String
  totalCount: Int!
}

input CreateUserInput {
  first_name: String!
  last_name: String!
  email: String!
  organization: String
  group_name: String
  first_address: String
  second_address: String
  city: String
  state: String
  zipcode: String
  country: String
  phone: String
  is_active: Boolean!
}

input UpdateUserInput {
  first_name: String
  last_name: String
  organization: String
  group_name: String
  first_address: String
  second_address: String
  city: String
  state: String
  zipcode: String
  country: String
  phone: String
  is_active: Boolean
}

input CreateRoleInput {
  role: String!
  description: String!
}

input UpdateRoleInput {
  role: String!
  description: String!
}

input CreatePermissionInput {
  permission: String!
  description: String!
  resource: String!
}

input UpdatePermissionInput {
  permission: String!
  description: String!
  resource: String!
}

type DeleteUser {
  success: Boolean!
}

type DeleteRole {
  success: Boolean!
}

type DeletePermission {
  success: Boolean!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
