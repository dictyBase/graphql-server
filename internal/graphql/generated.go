// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Annotation struct {
		Id            func(childComplexity int) int
		Value         func(childComplexity int) int
		EditableValue func(childComplexity int) int
		CreatedBy     func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		Tag           func(childComplexity int) int
		Version       func(childComplexity int) int
		EntryId       func(childComplexity int) int
		Ontology      func(childComplexity int) int
		Rank          func(childComplexity int) int
		IsObsolete    func(childComplexity int) int
	}

	AnnotationListWithCursor struct {
		Annotations    func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		Limit          func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	Author struct {
		LastName  func(childComplexity int) int
		FirstName func(childComplexity int) int
		Initials  func(childComplexity int) int
		Rank      func(childComplexity int) int
	}

	DeleteItem struct {
		Success func(childComplexity int) int
	}

	Mutation struct {
		CreateAnnotation  func(childComplexity int, input *CreateAnnotationInput) int
		UpdateAnnotation  func(childComplexity int, id string, input *UpdateAnnotationInput) int
		DeleteAnnotation  func(childComplexity int, id string) int
		CreateOrder       func(childComplexity int, input *CreateOrderInput) int
		UpdateOrder       func(childComplexity int, id string, input *UpdateOrderInput) int
		CreatePublication func(childComplexity int, input *CreatePublicationInput) int
		UpdatePublication func(childComplexity int, id string, input *UpdatePublicationInput) int
		DeletePublication func(childComplexity int, id string) int
		CreateStrain      func(childComplexity int, input *CreateStrainInput) int
		CreatePlasmid     func(childComplexity int, input *CreatePlasmidInput) int
		UpdateStock       func(childComplexity int, id string, input *UpdateStockInput) int
		DeleteStock       func(childComplexity int, id string) int
		CreateUser        func(childComplexity int, input *CreateUserInput) int
		UpdateUser        func(childComplexity int, id string, input *UpdateUserInput) int
		DeleteUser        func(childComplexity int, id string) int
		CreateRole        func(childComplexity int, input *CreateRoleInput) int
		UpdateRole        func(childComplexity int, id string, input *UpdateRoleInput) int
		DeleteRole        func(childComplexity int, id string) int
		CreatePermission  func(childComplexity int, input *CreatePermissionInput) int
		UpdatePermission  func(childComplexity int, id string, input *UpdatePermissionInput) int
		DeletePermission  func(childComplexity int, id string) int
	}

	Order struct {
		Id               func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		Courier          func(childComplexity int) int
		CourerAccount    func(childComplexity int) int
		Comments         func(childComplexity int) int
		Payment          func(childComplexity int) int
		PurchaseOrderNum func(childComplexity int) int
		Status           func(childComplexity int) int
		Consumer         func(childComplexity int) int
		Payer            func(childComplexity int) int
		Purchaser        func(childComplexity int) int
		Items            func(childComplexity int) int
	}

	OrderListWithCursor struct {
		Orders         func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		Limit          func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	Permission struct {
		Id          func(childComplexity int) int
		Permission  func(childComplexity int) int
		Description func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Resource    func(childComplexity int) int
	}

	PlasmidProperties struct {
		ImageMap func(childComplexity int) int
		Sequence func(childComplexity int) int
	}

	Publication struct {
		Id       func(childComplexity int) int
		Doi      func(childComplexity int) int
		Title    func(childComplexity int) int
		Abstract func(childComplexity int) int
		Journal  func(childComplexity int) int
		PubDate  func(childComplexity int) int
		Volume   func(childComplexity int) int
		Pages    func(childComplexity int) int
		Issn     func(childComplexity int) int
		PubType  func(childComplexity int) int
		Source   func(childComplexity int) int
		Issue    func(childComplexity int) int
		Status   func(childComplexity int) int
		Authors  func(childComplexity int) int
	}

	PublicationListWithCursor struct {
		Publications   func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		Limit          func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	Query struct {
		Annotation        func(childComplexity int, id string) int
		AnnotationByEntry func(childComplexity int, tag string, entry_id string, ontology string, rank *int, is_obsolete *bool) int
		ListAnnotations   func(childComplexity int, cursor *string, limit *int, filter *string) int
		Order             func(childComplexity int, id string) int
		ListOrders        func(childComplexity int, cursor *string, limit *int, filter *string) int
		Publication       func(childComplexity int, id string) int
		ListPublications  func(childComplexity int, cursor *string, limit *int, filter *string) int
		Stock             func(childComplexity int, id string) int
		ListStocks        func(childComplexity int, cursor *string, limit *int, filter *string) int
		User              func(childComplexity int, id string) int
		UserByEmail       func(childComplexity int, email string) int
		ListUsers         func(childComplexity int, cursor *string, limit *int, filter *string) int
		Role              func(childComplexity int, id string) int
		ListRoles         func(childComplexity int) int
		Permission        func(childComplexity int, id string) int
		ListPermissions   func(childComplexity int) int
	}

	Role struct {
		Id          func(childComplexity int) int
		Role        func(childComplexity int) int
		Description func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Permissions func(childComplexity int) int
	}

	Stock struct {
		Id                func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		CreatedBy         func(childComplexity int) int
		UpdatedBy         func(childComplexity int) int
		Summary           func(childComplexity int) int
		EditableSummary   func(childComplexity int) int
		Depositor         func(childComplexity int) int
		Genes             func(childComplexity int) int
		Dbxrefs           func(childComplexity int) int
		Publications      func(childComplexity int) int
		StrainProperties  func(childComplexity int) int
		PlasmidProperties func(childComplexity int) int
	}

	StockListWithCursor struct {
		Stocks         func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		Limit          func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}

	StrainProperties struct {
		SystematicName func(childComplexity int) int
		Descriptor     func(childComplexity int) int
		Species        func(childComplexity int) int
		Plasmid        func(childComplexity int) int
		Parents        func(childComplexity int) int
		Names          func(childComplexity int) int
	}

	User struct {
		Id            func(childComplexity int) int
		FirstName     func(childComplexity int) int
		LastName      func(childComplexity int) int
		Email         func(childComplexity int) int
		Organization  func(childComplexity int) int
		GroupName     func(childComplexity int) int
		FirstAddress  func(childComplexity int) int
		SecondAddress func(childComplexity int) int
		City          func(childComplexity int) int
		State         func(childComplexity int) int
		Zipcode       func(childComplexity int) int
		Country       func(childComplexity int) int
		Phone         func(childComplexity int) int
		IsActive      func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Roles         func(childComplexity int) int
	}

	UserListWithCursor struct {
		Users          func(childComplexity int) int
		NextCursor     func(childComplexity int) int
		PreviousCursor func(childComplexity int) int
		Limit          func(childComplexity int) int
		TotalCount     func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateAnnotation(ctx context.Context, input *CreateAnnotationInput) (*Annotation, error)
	UpdateAnnotation(ctx context.Context, id string, input *UpdateAnnotationInput) (*Annotation, error)
	DeleteAnnotation(ctx context.Context, id string) (*DeleteItem, error)
	CreateOrder(ctx context.Context, input *CreateOrderInput) (*Order, error)
	UpdateOrder(ctx context.Context, id string, input *UpdateOrderInput) (*Order, error)
	CreatePublication(ctx context.Context, input *CreatePublicationInput) (*Publication, error)
	UpdatePublication(ctx context.Context, id string, input *UpdatePublicationInput) (*Publication, error)
	DeletePublication(ctx context.Context, id string) (*DeleteItem, error)
	CreateStrain(ctx context.Context, input *CreateStrainInput) (*Stock, error)
	CreatePlasmid(ctx context.Context, input *CreatePlasmidInput) (*Stock, error)
	UpdateStock(ctx context.Context, id string, input *UpdateStockInput) (*Stock, error)
	DeleteStock(ctx context.Context, id string) (*DeleteItem, error)
	CreateUser(ctx context.Context, input *CreateUserInput) (*User, error)
	UpdateUser(ctx context.Context, id string, input *UpdateUserInput) (*User, error)
	DeleteUser(ctx context.Context, id string) (*DeleteItem, error)
	CreateRole(ctx context.Context, input *CreateRoleInput) (*Role, error)
	UpdateRole(ctx context.Context, id string, input *UpdateRoleInput) (*Role, error)
	DeleteRole(ctx context.Context, id string) (*DeleteItem, error)
	CreatePermission(ctx context.Context, input *CreatePermissionInput) (*Permission, error)
	UpdatePermission(ctx context.Context, id string, input *UpdatePermissionInput) (*Permission, error)
	DeletePermission(ctx context.Context, id string) (*DeleteItem, error)
}
type QueryResolver interface {
	Annotation(ctx context.Context, id string) (*Annotation, error)
	AnnotationByEntry(ctx context.Context, tag string, entry_id string, ontology string, rank *int, is_obsolete *bool) (*Annotation, error)
	ListAnnotations(ctx context.Context, cursor *string, limit *int, filter *string) (*AnnotationListWithCursor, error)
	Order(ctx context.Context, id string) (*Order, error)
	ListOrders(ctx context.Context, cursor *string, limit *int, filter *string) (*OrderListWithCursor, error)
	Publication(ctx context.Context, id string) (*Publication, error)
	ListPublications(ctx context.Context, cursor *string, limit *int, filter *string) (*PublicationListWithCursor, error)
	Stock(ctx context.Context, id string) (*Stock, error)
	ListStocks(ctx context.Context, cursor *string, limit *int, filter *string) (*StockListWithCursor, error)
	User(ctx context.Context, id string) (*User, error)
	UserByEmail(ctx context.Context, email string) (*User, error)
	ListUsers(ctx context.Context, cursor *string, limit *int, filter *string) (*UserListWithCursor, error)
	Role(ctx context.Context, id string) (*Role, error)
	ListRoles(ctx context.Context) ([]Role, error)
	Permission(ctx context.Context, id string) (*Permission, error)
	ListPermissions(ctx context.Context) ([]Permission, error)
}

func field_Mutation_createAnnotation_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *CreateAnnotationInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 CreateAnnotationInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateAnnotationInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updateAnnotation_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *UpdateAnnotationInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 UpdateAnnotationInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdateAnnotationInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deleteAnnotation_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Mutation_createOrder_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *CreateOrderInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 CreateOrderInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateOrderInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updateOrder_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *UpdateOrderInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 UpdateOrderInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdateOrderInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_createPublication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *CreatePublicationInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 CreatePublicationInput
		if tmp != nil {
			ptr1, err = UnmarshalCreatePublicationInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updatePublication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *UpdatePublicationInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 UpdatePublicationInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdatePublicationInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deletePublication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Mutation_createStrain_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *CreateStrainInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 CreateStrainInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateStrainInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_createPlasmid_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *CreatePlasmidInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 CreatePlasmidInput
		if tmp != nil {
			ptr1, err = UnmarshalCreatePlasmidInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updateStock_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *UpdateStockInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 UpdateStockInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdateStockInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deleteStock_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Mutation_createUser_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 CreateUserInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateUserInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updateUser_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *UpdateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 UpdateUserInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdateUserInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deleteUser_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Mutation_createRole_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *CreateRoleInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 CreateRoleInput
		if tmp != nil {
			ptr1, err = UnmarshalCreateRoleInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updateRole_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *UpdateRoleInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 UpdateRoleInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdateRoleInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deleteRole_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Mutation_createPermission_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *CreatePermissionInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 CreatePermissionInput
		if tmp != nil {
			ptr1, err = UnmarshalCreatePermissionInput(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil

}

func field_Mutation_updatePermission_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *UpdatePermissionInput
	if tmp, ok := rawArgs["input"]; ok {
		var err error
		var ptr1 UpdatePermissionInput
		if tmp != nil {
			ptr1, err = UnmarshalUpdatePermissionInput(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil

}

func field_Mutation_deletePermission_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_annotation_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_annotationByEntry_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["tag"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tag"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["entry_id"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["entry_id"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["ontology"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ontology"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["rank"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg3 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["rank"] = arg3
	var arg4 *bool
	if tmp, ok := rawArgs["is_obsolete"]; ok {
		var err error
		var ptr1 bool
		if tmp != nil {
			ptr1, err = graphql.UnmarshalBoolean(tmp)
			arg4 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["is_obsolete"] = arg4
	return args, nil

}

func field_Query_listAnnotations_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cursor"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalID(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["cursor"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg2
	return args, nil

}

func field_Query_order_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_listOrders_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cursor"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalID(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["cursor"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg2
	return args, nil

}

func field_Query_publication_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_listPublications_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cursor"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalID(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["cursor"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg2
	return args, nil

}

func field_Query_stock_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_listStocks_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cursor"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalID(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["cursor"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg2
	return args, nil

}

func field_Query_user_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_userByEmail_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["email"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg0
	return args, nil

}

func field_Query_listUsers_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["cursor"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalID(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["cursor"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		var err error
		var ptr1 int
		if tmp != nil {
			ptr1, err = graphql.UnmarshalInt(tmp)
			arg1 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["filter"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg2 = &ptr1
		}

		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg2
	return args, nil

}

func field_Query_role_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query_permission_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil

}

func field_Query___type_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil

}

func field___Type_fields_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

func field___Type_enumValues_args(rawArgs map[string]interface{}) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil

}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	switch typeName + "." + field {

	case "Annotation.id":
		if e.complexity.Annotation.Id == nil {
			break
		}

		return e.complexity.Annotation.Id(childComplexity), true

	case "Annotation.value":
		if e.complexity.Annotation.Value == nil {
			break
		}

		return e.complexity.Annotation.Value(childComplexity), true

	case "Annotation.editable_value":
		if e.complexity.Annotation.EditableValue == nil {
			break
		}

		return e.complexity.Annotation.EditableValue(childComplexity), true

	case "Annotation.created_by":
		if e.complexity.Annotation.CreatedBy == nil {
			break
		}

		return e.complexity.Annotation.CreatedBy(childComplexity), true

	case "Annotation.created_at":
		if e.complexity.Annotation.CreatedAt == nil {
			break
		}

		return e.complexity.Annotation.CreatedAt(childComplexity), true

	case "Annotation.tag":
		if e.complexity.Annotation.Tag == nil {
			break
		}

		return e.complexity.Annotation.Tag(childComplexity), true

	case "Annotation.version":
		if e.complexity.Annotation.Version == nil {
			break
		}

		return e.complexity.Annotation.Version(childComplexity), true

	case "Annotation.entry_id":
		if e.complexity.Annotation.EntryId == nil {
			break
		}

		return e.complexity.Annotation.EntryId(childComplexity), true

	case "Annotation.ontology":
		if e.complexity.Annotation.Ontology == nil {
			break
		}

		return e.complexity.Annotation.Ontology(childComplexity), true

	case "Annotation.rank":
		if e.complexity.Annotation.Rank == nil {
			break
		}

		return e.complexity.Annotation.Rank(childComplexity), true

	case "Annotation.is_obsolete":
		if e.complexity.Annotation.IsObsolete == nil {
			break
		}

		return e.complexity.Annotation.IsObsolete(childComplexity), true

	case "AnnotationListWithCursor.annotations":
		if e.complexity.AnnotationListWithCursor.Annotations == nil {
			break
		}

		return e.complexity.AnnotationListWithCursor.Annotations(childComplexity), true

	case "AnnotationListWithCursor.nextCursor":
		if e.complexity.AnnotationListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.AnnotationListWithCursor.NextCursor(childComplexity), true

	case "AnnotationListWithCursor.previousCursor":
		if e.complexity.AnnotationListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.AnnotationListWithCursor.PreviousCursor(childComplexity), true

	case "AnnotationListWithCursor.limit":
		if e.complexity.AnnotationListWithCursor.Limit == nil {
			break
		}

		return e.complexity.AnnotationListWithCursor.Limit(childComplexity), true

	case "AnnotationListWithCursor.totalCount":
		if e.complexity.AnnotationListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.AnnotationListWithCursor.TotalCount(childComplexity), true

	case "Author.last_name":
		if e.complexity.Author.LastName == nil {
			break
		}

		return e.complexity.Author.LastName(childComplexity), true

	case "Author.first_name":
		if e.complexity.Author.FirstName == nil {
			break
		}

		return e.complexity.Author.FirstName(childComplexity), true

	case "Author.initials":
		if e.complexity.Author.Initials == nil {
			break
		}

		return e.complexity.Author.Initials(childComplexity), true

	case "Author.rank":
		if e.complexity.Author.Rank == nil {
			break
		}

		return e.complexity.Author.Rank(childComplexity), true

	case "DeleteItem.success":
		if e.complexity.DeleteItem.Success == nil {
			break
		}

		return e.complexity.DeleteItem.Success(childComplexity), true

	case "Mutation.createAnnotation":
		if e.complexity.Mutation.CreateAnnotation == nil {
			break
		}

		args, err := field_Mutation_createAnnotation_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAnnotation(childComplexity, args["input"].(*CreateAnnotationInput)), true

	case "Mutation.updateAnnotation":
		if e.complexity.Mutation.UpdateAnnotation == nil {
			break
		}

		args, err := field_Mutation_updateAnnotation_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAnnotation(childComplexity, args["id"].(string), args["input"].(*UpdateAnnotationInput)), true

	case "Mutation.deleteAnnotation":
		if e.complexity.Mutation.DeleteAnnotation == nil {
			break
		}

		args, err := field_Mutation_deleteAnnotation_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAnnotation(childComplexity, args["id"].(string)), true

	case "Mutation.createOrder":
		if e.complexity.Mutation.CreateOrder == nil {
			break
		}

		args, err := field_Mutation_createOrder_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOrder(childComplexity, args["input"].(*CreateOrderInput)), true

	case "Mutation.updateOrder":
		if e.complexity.Mutation.UpdateOrder == nil {
			break
		}

		args, err := field_Mutation_updateOrder_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOrder(childComplexity, args["id"].(string), args["input"].(*UpdateOrderInput)), true

	case "Mutation.createPublication":
		if e.complexity.Mutation.CreatePublication == nil {
			break
		}

		args, err := field_Mutation_createPublication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePublication(childComplexity, args["input"].(*CreatePublicationInput)), true

	case "Mutation.updatePublication":
		if e.complexity.Mutation.UpdatePublication == nil {
			break
		}

		args, err := field_Mutation_updatePublication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePublication(childComplexity, args["id"].(string), args["input"].(*UpdatePublicationInput)), true

	case "Mutation.deletePublication":
		if e.complexity.Mutation.DeletePublication == nil {
			break
		}

		args, err := field_Mutation_deletePublication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePublication(childComplexity, args["id"].(string)), true

	case "Mutation.createStrain":
		if e.complexity.Mutation.CreateStrain == nil {
			break
		}

		args, err := field_Mutation_createStrain_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateStrain(childComplexity, args["input"].(*CreateStrainInput)), true

	case "Mutation.createPlasmid":
		if e.complexity.Mutation.CreatePlasmid == nil {
			break
		}

		args, err := field_Mutation_createPlasmid_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePlasmid(childComplexity, args["input"].(*CreatePlasmidInput)), true

	case "Mutation.updateStock":
		if e.complexity.Mutation.UpdateStock == nil {
			break
		}

		args, err := field_Mutation_updateStock_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateStock(childComplexity, args["id"].(string), args["input"].(*UpdateStockInput)), true

	case "Mutation.deleteStock":
		if e.complexity.Mutation.DeleteStock == nil {
			break
		}

		args, err := field_Mutation_deleteStock_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteStock(childComplexity, args["id"].(string)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := field_Mutation_createUser_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(*CreateUserInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := field_Mutation_updateUser_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(string), args["input"].(*UpdateUserInput)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := field_Mutation_deleteUser_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(string)), true

	case "Mutation.createRole":
		if e.complexity.Mutation.CreateRole == nil {
			break
		}

		args, err := field_Mutation_createRole_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateRole(childComplexity, args["input"].(*CreateRoleInput)), true

	case "Mutation.updateRole":
		if e.complexity.Mutation.UpdateRole == nil {
			break
		}

		args, err := field_Mutation_updateRole_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRole(childComplexity, args["id"].(string), args["input"].(*UpdateRoleInput)), true

	case "Mutation.deleteRole":
		if e.complexity.Mutation.DeleteRole == nil {
			break
		}

		args, err := field_Mutation_deleteRole_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteRole(childComplexity, args["id"].(string)), true

	case "Mutation.createPermission":
		if e.complexity.Mutation.CreatePermission == nil {
			break
		}

		args, err := field_Mutation_createPermission_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePermission(childComplexity, args["input"].(*CreatePermissionInput)), true

	case "Mutation.updatePermission":
		if e.complexity.Mutation.UpdatePermission == nil {
			break
		}

		args, err := field_Mutation_updatePermission_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePermission(childComplexity, args["id"].(string), args["input"].(*UpdatePermissionInput)), true

	case "Mutation.deletePermission":
		if e.complexity.Mutation.DeletePermission == nil {
			break
		}

		args, err := field_Mutation_deletePermission_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePermission(childComplexity, args["id"].(string)), true

	case "Order.id":
		if e.complexity.Order.Id == nil {
			break
		}

		return e.complexity.Order.Id(childComplexity), true

	case "Order.created_at":
		if e.complexity.Order.CreatedAt == nil {
			break
		}

		return e.complexity.Order.CreatedAt(childComplexity), true

	case "Order.updated_at":
		if e.complexity.Order.UpdatedAt == nil {
			break
		}

		return e.complexity.Order.UpdatedAt(childComplexity), true

	case "Order.courier":
		if e.complexity.Order.Courier == nil {
			break
		}

		return e.complexity.Order.Courier(childComplexity), true

	case "Order.courer_account":
		if e.complexity.Order.CourerAccount == nil {
			break
		}

		return e.complexity.Order.CourerAccount(childComplexity), true

	case "Order.comments":
		if e.complexity.Order.Comments == nil {
			break
		}

		return e.complexity.Order.Comments(childComplexity), true

	case "Order.payment":
		if e.complexity.Order.Payment == nil {
			break
		}

		return e.complexity.Order.Payment(childComplexity), true

	case "Order.purchase_order_num":
		if e.complexity.Order.PurchaseOrderNum == nil {
			break
		}

		return e.complexity.Order.PurchaseOrderNum(childComplexity), true

	case "Order.status":
		if e.complexity.Order.Status == nil {
			break
		}

		return e.complexity.Order.Status(childComplexity), true

	case "Order.consumer":
		if e.complexity.Order.Consumer == nil {
			break
		}

		return e.complexity.Order.Consumer(childComplexity), true

	case "Order.payer":
		if e.complexity.Order.Payer == nil {
			break
		}

		return e.complexity.Order.Payer(childComplexity), true

	case "Order.purchaser":
		if e.complexity.Order.Purchaser == nil {
			break
		}

		return e.complexity.Order.Purchaser(childComplexity), true

	case "Order.Items":
		if e.complexity.Order.Items == nil {
			break
		}

		return e.complexity.Order.Items(childComplexity), true

	case "OrderListWithCursor.orders":
		if e.complexity.OrderListWithCursor.Orders == nil {
			break
		}

		return e.complexity.OrderListWithCursor.Orders(childComplexity), true

	case "OrderListWithCursor.nextCursor":
		if e.complexity.OrderListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.OrderListWithCursor.NextCursor(childComplexity), true

	case "OrderListWithCursor.previousCursor":
		if e.complexity.OrderListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.OrderListWithCursor.PreviousCursor(childComplexity), true

	case "OrderListWithCursor.limit":
		if e.complexity.OrderListWithCursor.Limit == nil {
			break
		}

		return e.complexity.OrderListWithCursor.Limit(childComplexity), true

	case "OrderListWithCursor.totalCount":
		if e.complexity.OrderListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.OrderListWithCursor.TotalCount(childComplexity), true

	case "Permission.id":
		if e.complexity.Permission.Id == nil {
			break
		}

		return e.complexity.Permission.Id(childComplexity), true

	case "Permission.permission":
		if e.complexity.Permission.Permission == nil {
			break
		}

		return e.complexity.Permission.Permission(childComplexity), true

	case "Permission.description":
		if e.complexity.Permission.Description == nil {
			break
		}

		return e.complexity.Permission.Description(childComplexity), true

	case "Permission.created_at":
		if e.complexity.Permission.CreatedAt == nil {
			break
		}

		return e.complexity.Permission.CreatedAt(childComplexity), true

	case "Permission.updated_at":
		if e.complexity.Permission.UpdatedAt == nil {
			break
		}

		return e.complexity.Permission.UpdatedAt(childComplexity), true

	case "Permission.resource":
		if e.complexity.Permission.Resource == nil {
			break
		}

		return e.complexity.Permission.Resource(childComplexity), true

	case "PlasmidProperties.image_map":
		if e.complexity.PlasmidProperties.ImageMap == nil {
			break
		}

		return e.complexity.PlasmidProperties.ImageMap(childComplexity), true

	case "PlasmidProperties.sequence":
		if e.complexity.PlasmidProperties.Sequence == nil {
			break
		}

		return e.complexity.PlasmidProperties.Sequence(childComplexity), true

	case "Publication.id":
		if e.complexity.Publication.Id == nil {
			break
		}

		return e.complexity.Publication.Id(childComplexity), true

	case "Publication.doi":
		if e.complexity.Publication.Doi == nil {
			break
		}

		return e.complexity.Publication.Doi(childComplexity), true

	case "Publication.title":
		if e.complexity.Publication.Title == nil {
			break
		}

		return e.complexity.Publication.Title(childComplexity), true

	case "Publication.abstract":
		if e.complexity.Publication.Abstract == nil {
			break
		}

		return e.complexity.Publication.Abstract(childComplexity), true

	case "Publication.journal":
		if e.complexity.Publication.Journal == nil {
			break
		}

		return e.complexity.Publication.Journal(childComplexity), true

	case "Publication.pub_date":
		if e.complexity.Publication.PubDate == nil {
			break
		}

		return e.complexity.Publication.PubDate(childComplexity), true

	case "Publication.volume":
		if e.complexity.Publication.Volume == nil {
			break
		}

		return e.complexity.Publication.Volume(childComplexity), true

	case "Publication.pages":
		if e.complexity.Publication.Pages == nil {
			break
		}

		return e.complexity.Publication.Pages(childComplexity), true

	case "Publication.issn":
		if e.complexity.Publication.Issn == nil {
			break
		}

		return e.complexity.Publication.Issn(childComplexity), true

	case "Publication.pub_type":
		if e.complexity.Publication.PubType == nil {
			break
		}

		return e.complexity.Publication.PubType(childComplexity), true

	case "Publication.source":
		if e.complexity.Publication.Source == nil {
			break
		}

		return e.complexity.Publication.Source(childComplexity), true

	case "Publication.issue":
		if e.complexity.Publication.Issue == nil {
			break
		}

		return e.complexity.Publication.Issue(childComplexity), true

	case "Publication.status":
		if e.complexity.Publication.Status == nil {
			break
		}

		return e.complexity.Publication.Status(childComplexity), true

	case "Publication.authors":
		if e.complexity.Publication.Authors == nil {
			break
		}

		return e.complexity.Publication.Authors(childComplexity), true

	case "PublicationListWithCursor.publications":
		if e.complexity.PublicationListWithCursor.Publications == nil {
			break
		}

		return e.complexity.PublicationListWithCursor.Publications(childComplexity), true

	case "PublicationListWithCursor.nextCursor":
		if e.complexity.PublicationListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.PublicationListWithCursor.NextCursor(childComplexity), true

	case "PublicationListWithCursor.previousCursor":
		if e.complexity.PublicationListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.PublicationListWithCursor.PreviousCursor(childComplexity), true

	case "PublicationListWithCursor.limit":
		if e.complexity.PublicationListWithCursor.Limit == nil {
			break
		}

		return e.complexity.PublicationListWithCursor.Limit(childComplexity), true

	case "PublicationListWithCursor.totalCount":
		if e.complexity.PublicationListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.PublicationListWithCursor.TotalCount(childComplexity), true

	case "Query.annotation":
		if e.complexity.Query.Annotation == nil {
			break
		}

		args, err := field_Query_annotation_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Annotation(childComplexity, args["id"].(string)), true

	case "Query.annotationByEntry":
		if e.complexity.Query.AnnotationByEntry == nil {
			break
		}

		args, err := field_Query_annotationByEntry_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AnnotationByEntry(childComplexity, args["tag"].(string), args["entry_id"].(string), args["ontology"].(string), args["rank"].(*int), args["is_obsolete"].(*bool)), true

	case "Query.listAnnotations":
		if e.complexity.Query.ListAnnotations == nil {
			break
		}

		args, err := field_Query_listAnnotations_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListAnnotations(childComplexity, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string)), true

	case "Query.order":
		if e.complexity.Query.Order == nil {
			break
		}

		args, err := field_Query_order_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Order(childComplexity, args["id"].(string)), true

	case "Query.listOrders":
		if e.complexity.Query.ListOrders == nil {
			break
		}

		args, err := field_Query_listOrders_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListOrders(childComplexity, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string)), true

	case "Query.publication":
		if e.complexity.Query.Publication == nil {
			break
		}

		args, err := field_Query_publication_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Publication(childComplexity, args["id"].(string)), true

	case "Query.listPublications":
		if e.complexity.Query.ListPublications == nil {
			break
		}

		args, err := field_Query_listPublications_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListPublications(childComplexity, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string)), true

	case "Query.stock":
		if e.complexity.Query.Stock == nil {
			break
		}

		args, err := field_Query_stock_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Stock(childComplexity, args["id"].(string)), true

	case "Query.listStocks":
		if e.complexity.Query.ListStocks == nil {
			break
		}

		args, err := field_Query_listStocks_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListStocks(childComplexity, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := field_Query_user_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(string)), true

	case "Query.userByEmail":
		if e.complexity.Query.UserByEmail == nil {
			break
		}

		args, err := field_Query_userByEmail_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserByEmail(childComplexity, args["email"].(string)), true

	case "Query.listUsers":
		if e.complexity.Query.ListUsers == nil {
			break
		}

		args, err := field_Query_listUsers_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListUsers(childComplexity, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string)), true

	case "Query.role":
		if e.complexity.Query.Role == nil {
			break
		}

		args, err := field_Query_role_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Role(childComplexity, args["id"].(string)), true

	case "Query.listRoles":
		if e.complexity.Query.ListRoles == nil {
			break
		}

		return e.complexity.Query.ListRoles(childComplexity), true

	case "Query.permission":
		if e.complexity.Query.Permission == nil {
			break
		}

		args, err := field_Query_permission_args(rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Permission(childComplexity, args["id"].(string)), true

	case "Query.listPermissions":
		if e.complexity.Query.ListPermissions == nil {
			break
		}

		return e.complexity.Query.ListPermissions(childComplexity), true

	case "Role.id":
		if e.complexity.Role.Id == nil {
			break
		}

		return e.complexity.Role.Id(childComplexity), true

	case "Role.role":
		if e.complexity.Role.Role == nil {
			break
		}

		return e.complexity.Role.Role(childComplexity), true

	case "Role.description":
		if e.complexity.Role.Description == nil {
			break
		}

		return e.complexity.Role.Description(childComplexity), true

	case "Role.created_at":
		if e.complexity.Role.CreatedAt == nil {
			break
		}

		return e.complexity.Role.CreatedAt(childComplexity), true

	case "Role.updated_at":
		if e.complexity.Role.UpdatedAt == nil {
			break
		}

		return e.complexity.Role.UpdatedAt(childComplexity), true

	case "Role.permissions":
		if e.complexity.Role.Permissions == nil {
			break
		}

		return e.complexity.Role.Permissions(childComplexity), true

	case "Stock.id":
		if e.complexity.Stock.Id == nil {
			break
		}

		return e.complexity.Stock.Id(childComplexity), true

	case "Stock.created_at":
		if e.complexity.Stock.CreatedAt == nil {
			break
		}

		return e.complexity.Stock.CreatedAt(childComplexity), true

	case "Stock.updated_at":
		if e.complexity.Stock.UpdatedAt == nil {
			break
		}

		return e.complexity.Stock.UpdatedAt(childComplexity), true

	case "Stock.created_by":
		if e.complexity.Stock.CreatedBy == nil {
			break
		}

		return e.complexity.Stock.CreatedBy(childComplexity), true

	case "Stock.updated_by":
		if e.complexity.Stock.UpdatedBy == nil {
			break
		}

		return e.complexity.Stock.UpdatedBy(childComplexity), true

	case "Stock.summary":
		if e.complexity.Stock.Summary == nil {
			break
		}

		return e.complexity.Stock.Summary(childComplexity), true

	case "Stock.editable_summary":
		if e.complexity.Stock.EditableSummary == nil {
			break
		}

		return e.complexity.Stock.EditableSummary(childComplexity), true

	case "Stock.depositor":
		if e.complexity.Stock.Depositor == nil {
			break
		}

		return e.complexity.Stock.Depositor(childComplexity), true

	case "Stock.genes":
		if e.complexity.Stock.Genes == nil {
			break
		}

		return e.complexity.Stock.Genes(childComplexity), true

	case "Stock.dbxrefs":
		if e.complexity.Stock.Dbxrefs == nil {
			break
		}

		return e.complexity.Stock.Dbxrefs(childComplexity), true

	case "Stock.publications":
		if e.complexity.Stock.Publications == nil {
			break
		}

		return e.complexity.Stock.Publications(childComplexity), true

	case "Stock.strain_properties":
		if e.complexity.Stock.StrainProperties == nil {
			break
		}

		return e.complexity.Stock.StrainProperties(childComplexity), true

	case "Stock.plasmid_properties":
		if e.complexity.Stock.PlasmidProperties == nil {
			break
		}

		return e.complexity.Stock.PlasmidProperties(childComplexity), true

	case "StockListWithCursor.stocks":
		if e.complexity.StockListWithCursor.Stocks == nil {
			break
		}

		return e.complexity.StockListWithCursor.Stocks(childComplexity), true

	case "StockListWithCursor.nextCursor":
		if e.complexity.StockListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.StockListWithCursor.NextCursor(childComplexity), true

	case "StockListWithCursor.previousCursor":
		if e.complexity.StockListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.StockListWithCursor.PreviousCursor(childComplexity), true

	case "StockListWithCursor.limit":
		if e.complexity.StockListWithCursor.Limit == nil {
			break
		}

		return e.complexity.StockListWithCursor.Limit(childComplexity), true

	case "StockListWithCursor.totalCount":
		if e.complexity.StockListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.StockListWithCursor.TotalCount(childComplexity), true

	case "StrainProperties.systematic_name":
		if e.complexity.StrainProperties.SystematicName == nil {
			break
		}

		return e.complexity.StrainProperties.SystematicName(childComplexity), true

	case "StrainProperties.descriptor":
		if e.complexity.StrainProperties.Descriptor == nil {
			break
		}

		return e.complexity.StrainProperties.Descriptor(childComplexity), true

	case "StrainProperties.species":
		if e.complexity.StrainProperties.Species == nil {
			break
		}

		return e.complexity.StrainProperties.Species(childComplexity), true

	case "StrainProperties.plasmid":
		if e.complexity.StrainProperties.Plasmid == nil {
			break
		}

		return e.complexity.StrainProperties.Plasmid(childComplexity), true

	case "StrainProperties.parents":
		if e.complexity.StrainProperties.Parents == nil {
			break
		}

		return e.complexity.StrainProperties.Parents(childComplexity), true

	case "StrainProperties.names":
		if e.complexity.StrainProperties.Names == nil {
			break
		}

		return e.complexity.StrainProperties.Names(childComplexity), true

	case "User.id":
		if e.complexity.User.Id == nil {
			break
		}

		return e.complexity.User.Id(childComplexity), true

	case "User.first_name":
		if e.complexity.User.FirstName == nil {
			break
		}

		return e.complexity.User.FirstName(childComplexity), true

	case "User.last_name":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.organization":
		if e.complexity.User.Organization == nil {
			break
		}

		return e.complexity.User.Organization(childComplexity), true

	case "User.group_name":
		if e.complexity.User.GroupName == nil {
			break
		}

		return e.complexity.User.GroupName(childComplexity), true

	case "User.first_address":
		if e.complexity.User.FirstAddress == nil {
			break
		}

		return e.complexity.User.FirstAddress(childComplexity), true

	case "User.second_address":
		if e.complexity.User.SecondAddress == nil {
			break
		}

		return e.complexity.User.SecondAddress(childComplexity), true

	case "User.city":
		if e.complexity.User.City == nil {
			break
		}

		return e.complexity.User.City(childComplexity), true

	case "User.state":
		if e.complexity.User.State == nil {
			break
		}

		return e.complexity.User.State(childComplexity), true

	case "User.zipcode":
		if e.complexity.User.Zipcode == nil {
			break
		}

		return e.complexity.User.Zipcode(childComplexity), true

	case "User.country":
		if e.complexity.User.Country == nil {
			break
		}

		return e.complexity.User.Country(childComplexity), true

	case "User.phone":
		if e.complexity.User.Phone == nil {
			break
		}

		return e.complexity.User.Phone(childComplexity), true

	case "User.is_active":
		if e.complexity.User.IsActive == nil {
			break
		}

		return e.complexity.User.IsActive(childComplexity), true

	case "User.created_at":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.updated_at":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "UserListWithCursor.users":
		if e.complexity.UserListWithCursor.Users == nil {
			break
		}

		return e.complexity.UserListWithCursor.Users(childComplexity), true

	case "UserListWithCursor.nextCursor":
		if e.complexity.UserListWithCursor.NextCursor == nil {
			break
		}

		return e.complexity.UserListWithCursor.NextCursor(childComplexity), true

	case "UserListWithCursor.previousCursor":
		if e.complexity.UserListWithCursor.PreviousCursor == nil {
			break
		}

		return e.complexity.UserListWithCursor.PreviousCursor(childComplexity), true

	case "UserListWithCursor.limit":
		if e.complexity.UserListWithCursor.Limit == nil {
			break
		}

		return e.complexity.UserListWithCursor.Limit(childComplexity), true

	case "UserListWithCursor.totalCount":
		if e.complexity.UserListWithCursor.TotalCount == nil {
			break
		}

		return e.complexity.UserListWithCursor.TotalCount(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var annotationImplementors = []string{"Annotation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Annotation(ctx context.Context, sel ast.SelectionSet, obj *Annotation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, annotationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Annotation")
		case "id":
			out.Values[i] = ec._Annotation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._Annotation_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "editable_value":
			out.Values[i] = ec._Annotation_editable_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "created_by":
			out.Values[i] = ec._Annotation_created_by(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "created_at":
			out.Values[i] = ec._Annotation_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "tag":
			out.Values[i] = ec._Annotation_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "version":
			out.Values[i] = ec._Annotation_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "entry_id":
			out.Values[i] = ec._Annotation_entry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "ontology":
			out.Values[i] = ec._Annotation_ontology(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rank":
			out.Values[i] = ec._Annotation_rank(ctx, field, obj)
		case "is_obsolete":
			out.Values[i] = ec._Annotation_is_obsolete(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_id(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_value(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_editable_value(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditableValue, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_created_by(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_created_at(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_tag(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_version(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_entry_id(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntryID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_ontology(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ontology, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_rank(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rank, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Annotation_is_obsolete(ctx context.Context, field graphql.CollectedField, obj *Annotation) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Annotation",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsObsolete, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*res)
}

var annotationListWithCursorImplementors = []string{"AnnotationListWithCursor"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AnnotationListWithCursor(ctx context.Context, sel ast.SelectionSet, obj *AnnotationListWithCursor) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, annotationListWithCursorImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AnnotationListWithCursor")
		case "annotations":
			out.Values[i] = ec._AnnotationListWithCursor_annotations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nextCursor":
			out.Values[i] = ec._AnnotationListWithCursor_nextCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "previousCursor":
			out.Values[i] = ec._AnnotationListWithCursor_previousCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "limit":
			out.Values[i] = ec._AnnotationListWithCursor_limit(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._AnnotationListWithCursor_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _AnnotationListWithCursor_annotations(ctx context.Context, field graphql.CollectedField, obj *AnnotationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AnnotationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Annotation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Annotation(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _AnnotationListWithCursor_nextCursor(ctx context.Context, field graphql.CollectedField, obj *AnnotationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AnnotationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _AnnotationListWithCursor_previousCursor(ctx context.Context, field graphql.CollectedField, obj *AnnotationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AnnotationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _AnnotationListWithCursor_limit(ctx context.Context, field graphql.CollectedField, obj *AnnotationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AnnotationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _AnnotationListWithCursor_totalCount(ctx context.Context, field graphql.CollectedField, obj *AnnotationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "AnnotationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var authorImplementors = []string{"Author"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Author(ctx context.Context, sel ast.SelectionSet, obj *Author) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, authorImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Author")
		case "last_name":
			out.Values[i] = ec._Author_last_name(ctx, field, obj)
		case "first_name":
			out.Values[i] = ec._Author_first_name(ctx, field, obj)
		case "initials":
			out.Values[i] = ec._Author_initials(ctx, field, obj)
		case "rank":
			out.Values[i] = ec._Author_rank(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Author_last_name(ctx context.Context, field graphql.CollectedField, obj *Author) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Author",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Author_first_name(ctx context.Context, field graphql.CollectedField, obj *Author) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Author",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Author_initials(ctx context.Context, field graphql.CollectedField, obj *Author) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Author",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Initials, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Author_rank(ctx context.Context, field graphql.CollectedField, obj *Author) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Author",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rank, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var deleteItemImplementors = []string{"DeleteItem"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _DeleteItem(ctx context.Context, sel ast.SelectionSet, obj *DeleteItem) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, deleteItemImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteItem")
		case "success":
			out.Values[i] = ec._DeleteItem_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _DeleteItem_success(ctx context.Context, field graphql.CollectedField, obj *DeleteItem) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "DeleteItem",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createAnnotation":
			out.Values[i] = ec._Mutation_createAnnotation(ctx, field)
		case "updateAnnotation":
			out.Values[i] = ec._Mutation_updateAnnotation(ctx, field)
		case "deleteAnnotation":
			out.Values[i] = ec._Mutation_deleteAnnotation(ctx, field)
		case "createOrder":
			out.Values[i] = ec._Mutation_createOrder(ctx, field)
		case "updateOrder":
			out.Values[i] = ec._Mutation_updateOrder(ctx, field)
		case "createPublication":
			out.Values[i] = ec._Mutation_createPublication(ctx, field)
		case "updatePublication":
			out.Values[i] = ec._Mutation_updatePublication(ctx, field)
		case "deletePublication":
			out.Values[i] = ec._Mutation_deletePublication(ctx, field)
		case "createStrain":
			out.Values[i] = ec._Mutation_createStrain(ctx, field)
		case "createPlasmid":
			out.Values[i] = ec._Mutation_createPlasmid(ctx, field)
		case "updateStock":
			out.Values[i] = ec._Mutation_updateStock(ctx, field)
		case "deleteStock":
			out.Values[i] = ec._Mutation_deleteStock(ctx, field)
		case "createUser":
			out.Values[i] = ec._Mutation_createUser(ctx, field)
		case "updateUser":
			out.Values[i] = ec._Mutation_updateUser(ctx, field)
		case "deleteUser":
			out.Values[i] = ec._Mutation_deleteUser(ctx, field)
		case "createRole":
			out.Values[i] = ec._Mutation_createRole(ctx, field)
		case "updateRole":
			out.Values[i] = ec._Mutation_updateRole(ctx, field)
		case "deleteRole":
			out.Values[i] = ec._Mutation_deleteRole(ctx, field)
		case "createPermission":
			out.Values[i] = ec._Mutation_createPermission(ctx, field)
		case "updatePermission":
			out.Values[i] = ec._Mutation_updatePermission(ctx, field)
		case "deletePermission":
			out.Values[i] = ec._Mutation_deletePermission(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createAnnotation(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createAnnotation_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateAnnotation(rctx, args["input"].(*CreateAnnotationInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Annotation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Annotation(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateAnnotation(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateAnnotation_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateAnnotation(rctx, args["id"].(string), args["input"].(*UpdateAnnotationInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Annotation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Annotation(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteAnnotation(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteAnnotation_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAnnotation(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteItem(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createOrder(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createOrder_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateOrder(rctx, args["input"].(*CreateOrderInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Order)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Order(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateOrder(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateOrder_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateOrder(rctx, args["id"].(string), args["input"].(*UpdateOrderInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Order)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Order(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createPublication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createPublication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePublication(rctx, args["input"].(*CreatePublicationInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Publication)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Publication(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updatePublication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updatePublication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePublication(rctx, args["id"].(string), args["input"].(*UpdatePublicationInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Publication)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Publication(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deletePublication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deletePublication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePublication(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteItem(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createStrain(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createStrain_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateStrain(rctx, args["input"].(*CreateStrainInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Stock(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createPlasmid(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createPlasmid_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePlasmid(rctx, args["input"].(*CreatePlasmidInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Stock(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateStock(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateStock_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateStock(rctx, args["id"].(string), args["input"].(*UpdateStockInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Stock(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteStock(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteStock_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteStock(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteItem(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createUser_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, args["input"].(*CreateUserInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._User(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateUser_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUser(rctx, args["id"].(string), args["input"].(*UpdateUserInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._User(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteUser_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteUser(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteItem(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createRole(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createRole_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateRole(rctx, args["input"].(*CreateRoleInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Role(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updateRole(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updateRole_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateRole(rctx, args["id"].(string), args["input"].(*UpdateRoleInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Role(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deleteRole(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deleteRole_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteRole(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteItem(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_createPermission(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_createPermission_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePermission(rctx, args["input"].(*CreatePermissionInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Permission(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_updatePermission(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_updatePermission_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePermission(rctx, args["id"].(string), args["input"].(*UpdatePermissionInput))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Permission(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Mutation_deletePermission(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Mutation_deletePermission_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePermission(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteItem)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._DeleteItem(ctx, field.Selections, res)
}

var orderImplementors = []string{"Order"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Order(ctx context.Context, sel ast.SelectionSet, obj *Order) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, orderImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Order")
		case "id":
			out.Values[i] = ec._Order_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "created_at":
			out.Values[i] = ec._Order_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updated_at":
			out.Values[i] = ec._Order_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "courier":
			out.Values[i] = ec._Order_courier(ctx, field, obj)
		case "courer_account":
			out.Values[i] = ec._Order_courer_account(ctx, field, obj)
		case "comments":
			out.Values[i] = ec._Order_comments(ctx, field, obj)
		case "payment":
			out.Values[i] = ec._Order_payment(ctx, field, obj)
		case "purchase_order_num":
			out.Values[i] = ec._Order_purchase_order_num(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Order_status(ctx, field, obj)
		case "consumer":
			out.Values[i] = ec._Order_consumer(ctx, field, obj)
		case "payer":
			out.Values[i] = ec._Order_payer(ctx, field, obj)
		case "purchaser":
			out.Values[i] = ec._Order_purchaser(ctx, field, obj)
		case "Items":
			out.Values[i] = ec._Order_Items(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Order_id(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_created_at(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_updated_at(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_courier(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Courier, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_courer_account(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CourerAccount, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_comments(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comments, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_payment(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Payment, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_purchase_order_num(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PurchaseOrderNum, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_status(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_consumer(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Consumer, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_payer(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Payer, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_purchaser(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Purchaser, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Order_Items(ctx context.Context, field graphql.CollectedField, obj *Order) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Order",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

var orderListWithCursorImplementors = []string{"OrderListWithCursor"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OrderListWithCursor(ctx context.Context, sel ast.SelectionSet, obj *OrderListWithCursor) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, orderListWithCursorImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrderListWithCursor")
		case "orders":
			out.Values[i] = ec._OrderListWithCursor_orders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nextCursor":
			out.Values[i] = ec._OrderListWithCursor_nextCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "previousCursor":
			out.Values[i] = ec._OrderListWithCursor_previousCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "limit":
			out.Values[i] = ec._OrderListWithCursor_limit(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._OrderListWithCursor_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _OrderListWithCursor_orders(ctx context.Context, field graphql.CollectedField, obj *OrderListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "OrderListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Orders, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Order)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Order(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _OrderListWithCursor_nextCursor(ctx context.Context, field graphql.CollectedField, obj *OrderListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "OrderListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _OrderListWithCursor_previousCursor(ctx context.Context, field graphql.CollectedField, obj *OrderListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "OrderListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _OrderListWithCursor_limit(ctx context.Context, field graphql.CollectedField, obj *OrderListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "OrderListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _OrderListWithCursor_totalCount(ctx context.Context, field graphql.CollectedField, obj *OrderListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "OrderListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var permissionImplementors = []string{"Permission"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Permission(ctx context.Context, sel ast.SelectionSet, obj *Permission) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, permissionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Permission")
		case "id":
			out.Values[i] = ec._Permission_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "permission":
			out.Values[i] = ec._Permission_permission(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Permission_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "created_at":
			out.Values[i] = ec._Permission_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updated_at":
			out.Values[i] = ec._Permission_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resource":
			out.Values[i] = ec._Permission_resource(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Permission_id(ctx context.Context, field graphql.CollectedField, obj *Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_permission(ctx context.Context, field graphql.CollectedField, obj *Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Permission, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_description(ctx context.Context, field graphql.CollectedField, obj *Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_created_at(ctx context.Context, field graphql.CollectedField, obj *Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_updated_at(ctx context.Context, field graphql.CollectedField, obj *Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Permission_resource(ctx context.Context, field graphql.CollectedField, obj *Permission) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Permission",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var plasmidPropertiesImplementors = []string{"PlasmidProperties"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PlasmidProperties(ctx context.Context, sel ast.SelectionSet, obj *PlasmidProperties) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, plasmidPropertiesImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlasmidProperties")
		case "image_map":
			out.Values[i] = ec._PlasmidProperties_image_map(ctx, field, obj)
		case "sequence":
			out.Values[i] = ec._PlasmidProperties_sequence(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _PlasmidProperties_image_map(ctx context.Context, field graphql.CollectedField, obj *PlasmidProperties) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PlasmidProperties",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageMap, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _PlasmidProperties_sequence(ctx context.Context, field graphql.CollectedField, obj *PlasmidProperties) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PlasmidProperties",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sequence, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var publicationImplementors = []string{"Publication"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Publication(ctx context.Context, sel ast.SelectionSet, obj *Publication) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, publicationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Publication")
		case "id":
			out.Values[i] = ec._Publication_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "doi":
			out.Values[i] = ec._Publication_doi(ctx, field, obj)
		case "title":
			out.Values[i] = ec._Publication_title(ctx, field, obj)
		case "abstract":
			out.Values[i] = ec._Publication_abstract(ctx, field, obj)
		case "journal":
			out.Values[i] = ec._Publication_journal(ctx, field, obj)
		case "pub_date":
			out.Values[i] = ec._Publication_pub_date(ctx, field, obj)
		case "volume":
			out.Values[i] = ec._Publication_volume(ctx, field, obj)
		case "pages":
			out.Values[i] = ec._Publication_pages(ctx, field, obj)
		case "issn":
			out.Values[i] = ec._Publication_issn(ctx, field, obj)
		case "pub_type":
			out.Values[i] = ec._Publication_pub_type(ctx, field, obj)
		case "source":
			out.Values[i] = ec._Publication_source(ctx, field, obj)
		case "issue":
			out.Values[i] = ec._Publication_issue(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Publication_status(ctx, field, obj)
		case "authors":
			out.Values[i] = ec._Publication_authors(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Publication_id(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_doi(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Doi, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_title(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_abstract(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Abstract, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_journal(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Journal, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_pub_date(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PubDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_volume(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Volume, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_pages(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pages, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_issn(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issn, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_pub_type(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PubType, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_source(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_issue(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_status(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Publication_authors(ctx context.Context, field graphql.CollectedField, obj *Publication) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Publication",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Authors, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Author)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				if res[idx1] == nil {
					return graphql.Null
				}

				return ec._Author(ctx, field.Selections, res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var publicationListWithCursorImplementors = []string{"PublicationListWithCursor"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _PublicationListWithCursor(ctx context.Context, sel ast.SelectionSet, obj *PublicationListWithCursor) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, publicationListWithCursorImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublicationListWithCursor")
		case "publications":
			out.Values[i] = ec._PublicationListWithCursor_publications(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nextCursor":
			out.Values[i] = ec._PublicationListWithCursor_nextCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "previousCursor":
			out.Values[i] = ec._PublicationListWithCursor_previousCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "limit":
			out.Values[i] = ec._PublicationListWithCursor_limit(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._PublicationListWithCursor_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _PublicationListWithCursor_publications(ctx context.Context, field graphql.CollectedField, obj *PublicationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PublicationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Publications, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Publication)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Publication(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _PublicationListWithCursor_nextCursor(ctx context.Context, field graphql.CollectedField, obj *PublicationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PublicationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _PublicationListWithCursor_previousCursor(ctx context.Context, field graphql.CollectedField, obj *PublicationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PublicationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _PublicationListWithCursor_limit(ctx context.Context, field graphql.CollectedField, obj *PublicationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PublicationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _PublicationListWithCursor_totalCount(ctx context.Context, field graphql.CollectedField, obj *PublicationListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "PublicationListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "annotation":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_annotation(ctx, field)
				wg.Done()
			}(i, field)
		case "annotationByEntry":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_annotationByEntry(ctx, field)
				wg.Done()
			}(i, field)
		case "listAnnotations":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listAnnotations(ctx, field)
				wg.Done()
			}(i, field)
		case "order":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_order(ctx, field)
				wg.Done()
			}(i, field)
		case "listOrders":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listOrders(ctx, field)
				wg.Done()
			}(i, field)
		case "publication":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_publication(ctx, field)
				wg.Done()
			}(i, field)
		case "listPublications":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listPublications(ctx, field)
				wg.Done()
			}(i, field)
		case "stock":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_stock(ctx, field)
				wg.Done()
			}(i, field)
		case "listStocks":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listStocks(ctx, field)
				wg.Done()
			}(i, field)
		case "user":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_user(ctx, field)
				wg.Done()
			}(i, field)
		case "userByEmail":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_userByEmail(ctx, field)
				wg.Done()
			}(i, field)
		case "listUsers":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listUsers(ctx, field)
				wg.Done()
			}(i, field)
		case "role":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_role(ctx, field)
				wg.Done()
			}(i, field)
		case "listRoles":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listRoles(ctx, field)
				wg.Done()
			}(i, field)
		case "permission":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_permission(ctx, field)
				wg.Done()
			}(i, field)
		case "listPermissions":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_listPermissions(ctx, field)
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Query_annotation(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_annotation_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Annotation(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Annotation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Annotation(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_annotationByEntry(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_annotationByEntry_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AnnotationByEntry(rctx, args["tag"].(string), args["entry_id"].(string), args["ontology"].(string), args["rank"].(*int), args["is_obsolete"].(*bool))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Annotation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Annotation(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listAnnotations(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_listAnnotations_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListAnnotations(rctx, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AnnotationListWithCursor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._AnnotationListWithCursor(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_order(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_order_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Order(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Order)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Order(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listOrders(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_listOrders_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListOrders(rctx, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*OrderListWithCursor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._OrderListWithCursor(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_publication(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_publication_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Publication(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Publication)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Publication(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listPublications(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_listPublications_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListPublications(rctx, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PublicationListWithCursor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._PublicationListWithCursor(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_stock(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_stock_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Stock(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Stock(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listStocks(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_listStocks_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListStocks(rctx, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StockListWithCursor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._StockListWithCursor(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_user_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._User(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_userByEmail(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_userByEmail_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserByEmail(rctx, args["email"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._User(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listUsers(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_listUsers_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListUsers(rctx, args["cursor"].(*string), args["limit"].(*int), args["filter"].(*string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserListWithCursor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._UserListWithCursor(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_role(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_role_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Role(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Role(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listRoles(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListRoles(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Role(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query_permission(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query_permission_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Permission(rctx, args["id"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._Permission(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query_listPermissions(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ListPermissions(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Permission(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_Query___type_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Schema(ctx, field.Selections, res)
}

var roleImplementors = []string{"Role"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Role(ctx context.Context, sel ast.SelectionSet, obj *Role) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roleImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Role")
		case "id":
			out.Values[i] = ec._Role_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "role":
			out.Values[i] = ec._Role_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Role_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "created_at":
			out.Values[i] = ec._Role_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updated_at":
			out.Values[i] = ec._Role_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "permissions":
			out.Values[i] = ec._Role_permissions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Role_id(ctx context.Context, field graphql.CollectedField, obj *Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_role(ctx context.Context, field graphql.CollectedField, obj *Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_description(ctx context.Context, field graphql.CollectedField, obj *Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_created_at(ctx context.Context, field graphql.CollectedField, obj *Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_updated_at(ctx context.Context, field graphql.CollectedField, obj *Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Role_permissions(ctx context.Context, field graphql.CollectedField, obj *Role) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Role",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Permissions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Permission)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Permission(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var stockImplementors = []string{"Stock"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Stock(ctx context.Context, sel ast.SelectionSet, obj *Stock) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, stockImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Stock")
		case "id":
			out.Values[i] = ec._Stock_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "created_at":
			out.Values[i] = ec._Stock_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updated_at":
			out.Values[i] = ec._Stock_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "created_by":
			out.Values[i] = ec._Stock_created_by(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updated_by":
			out.Values[i] = ec._Stock_updated_by(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "summary":
			out.Values[i] = ec._Stock_summary(ctx, field, obj)
		case "editable_summary":
			out.Values[i] = ec._Stock_editable_summary(ctx, field, obj)
		case "depositor":
			out.Values[i] = ec._Stock_depositor(ctx, field, obj)
		case "genes":
			out.Values[i] = ec._Stock_genes(ctx, field, obj)
		case "dbxrefs":
			out.Values[i] = ec._Stock_dbxrefs(ctx, field, obj)
		case "publications":
			out.Values[i] = ec._Stock_publications(ctx, field, obj)
		case "strain_properties":
			out.Values[i] = ec._Stock_strain_properties(ctx, field, obj)
		case "plasmid_properties":
			out.Values[i] = ec._Stock_plasmid_properties(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _Stock_id(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _Stock_created_at(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Stock_updated_at(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Stock_created_by(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Stock_updated_by(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _Stock_summary(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Stock_editable_summary(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditableSummary, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Stock_depositor(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Depositor, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _Stock_genes(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Genes, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Stock_dbxrefs(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dbxrefs, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Stock_publications(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Publications, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _Stock_strain_properties(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StrainProperties, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StrainProperties)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._StrainProperties(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) _Stock_plasmid_properties(ctx context.Context, field graphql.CollectedField, obj *Stock) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "Stock",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlasmidProperties, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PlasmidProperties)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec._PlasmidProperties(ctx, field.Selections, res)
}

var stockListWithCursorImplementors = []string{"StockListWithCursor"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StockListWithCursor(ctx context.Context, sel ast.SelectionSet, obj *StockListWithCursor) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, stockListWithCursorImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StockListWithCursor")
		case "stocks":
			out.Values[i] = ec._StockListWithCursor_stocks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nextCursor":
			out.Values[i] = ec._StockListWithCursor_nextCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "previousCursor":
			out.Values[i] = ec._StockListWithCursor_previousCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "limit":
			out.Values[i] = ec._StockListWithCursor_limit(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._StockListWithCursor_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StockListWithCursor_stocks(ctx context.Context, field graphql.CollectedField, obj *StockListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StockListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stocks, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Stock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Stock(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _StockListWithCursor_nextCursor(ctx context.Context, field graphql.CollectedField, obj *StockListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StockListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _StockListWithCursor_previousCursor(ctx context.Context, field graphql.CollectedField, obj *StockListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StockListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _StockListWithCursor_limit(ctx context.Context, field graphql.CollectedField, obj *StockListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StockListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _StockListWithCursor_totalCount(ctx context.Context, field graphql.CollectedField, obj *StockListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StockListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var strainPropertiesImplementors = []string{"StrainProperties"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StrainProperties(ctx context.Context, sel ast.SelectionSet, obj *StrainProperties) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, strainPropertiesImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StrainProperties")
		case "systematic_name":
			out.Values[i] = ec._StrainProperties_systematic_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "descriptor":
			out.Values[i] = ec._StrainProperties_descriptor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "species":
			out.Values[i] = ec._StrainProperties_species(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plasmid":
			out.Values[i] = ec._StrainProperties_plasmid(ctx, field, obj)
		case "parents":
			out.Values[i] = ec._StrainProperties_parents(ctx, field, obj)
		case "names":
			out.Values[i] = ec._StrainProperties_names(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _StrainProperties_systematic_name(ctx context.Context, field graphql.CollectedField, obj *StrainProperties) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainProperties",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystematicName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _StrainProperties_descriptor(ctx context.Context, field graphql.CollectedField, obj *StrainProperties) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainProperties",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Descriptor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _StrainProperties_species(ctx context.Context, field graphql.CollectedField, obj *StrainProperties) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainProperties",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Species, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _StrainProperties_plasmid(ctx context.Context, field graphql.CollectedField, obj *StrainProperties) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainProperties",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plasmid, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _StrainProperties_parents(ctx context.Context, field graphql.CollectedField, obj *StrainProperties) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainProperties",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parents, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _StrainProperties_names(ctx context.Context, field graphql.CollectedField, obj *StrainProperties) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "StrainProperties",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Names, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			return graphql.MarshalString(*res[idx1])
		}()
	}

	return arr1
}

var userImplementors = []string{"User"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *User) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, userImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "first_name":
			out.Values[i] = ec._User_first_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "last_name":
			out.Values[i] = ec._User_last_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "organization":
			out.Values[i] = ec._User_organization(ctx, field, obj)
		case "group_name":
			out.Values[i] = ec._User_group_name(ctx, field, obj)
		case "first_address":
			out.Values[i] = ec._User_first_address(ctx, field, obj)
		case "second_address":
			out.Values[i] = ec._User_second_address(ctx, field, obj)
		case "city":
			out.Values[i] = ec._User_city(ctx, field, obj)
		case "state":
			out.Values[i] = ec._User_state(ctx, field, obj)
		case "zipcode":
			out.Values[i] = ec._User_zipcode(ctx, field, obj)
		case "country":
			out.Values[i] = ec._User_country(ctx, field, obj)
		case "phone":
			out.Values[i] = ec._User_phone(ctx, field, obj)
		case "is_active":
			out.Values[i] = ec._User_is_active(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "created_at":
			out.Values[i] = ec._User_created_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "updated_at":
			out.Values[i] = ec._User_updated_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "roles":
			out.Values[i] = ec._User_roles(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_first_name(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_last_name(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_organization(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organization, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_group_name(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_first_address(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstAddress, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_second_address(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecondAddress, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_city(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.City, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_state(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_zipcode(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zipcode, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_country(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Country, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_phone(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phone, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) _User_is_active(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_created_at(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_updated_at(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *User) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "User",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roles, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]Role)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._Role(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var userListWithCursorImplementors = []string{"UserListWithCursor"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UserListWithCursor(ctx context.Context, sel ast.SelectionSet, obj *UserListWithCursor) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, userListWithCursorImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserListWithCursor")
		case "users":
			out.Values[i] = ec._UserListWithCursor_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "nextCursor":
			out.Values[i] = ec._UserListWithCursor_nextCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "previousCursor":
			out.Values[i] = ec._UserListWithCursor_previousCursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "limit":
			out.Values[i] = ec._UserListWithCursor_limit(ctx, field, obj)
		case "totalCount":
			out.Values[i] = ec._UserListWithCursor_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) _UserListWithCursor_users(ctx context.Context, field graphql.CollectedField, obj *UserListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UserListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec._User(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) _UserListWithCursor_nextCursor(ctx context.Context, field graphql.CollectedField, obj *UserListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UserListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _UserListWithCursor_previousCursor(ctx context.Context, field graphql.CollectedField, obj *UserListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UserListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousCursor, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalID(res)
}

// nolint: vetshadow
func (ec *executionContext) _UserListWithCursor_limit(ctx context.Context, field graphql.CollectedField, obj *UserListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UserListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*res)
}

// nolint: vetshadow
func (ec *executionContext) _UserListWithCursor_totalCount(ctx context.Context, field graphql.CollectedField, obj *UserListWithCursor) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "UserListWithCursor",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalInt(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))

	for idx1 := range res {
		arr1[idx1] = func() graphql.Marshaler {
			return graphql.MarshalString(res[idx1])
		}()
	}

	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalBoolean(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

// nolint: vetshadow
func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Directive(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

// nolint: vetshadow
func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return graphql.MarshalString(res)
}

// nolint: vetshadow
func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_fields_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Field(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___Type(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field___Type_enumValues_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___EnumValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	arr1 := make(graphql.Array, len(res))
	var wg sync.WaitGroup

	isLen1 := len(res) == 1
	if !isLen1 {
		wg.Add(len(res))
	}

	for idx1 := range res {
		idx1 := idx1
		rctx := &graphql.ResolverContext{
			Index:  &idx1,
			Result: &res[idx1],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(idx1 int) {
			if !isLen1 {
				defer wg.Done()
			}
			arr1[idx1] = func() graphql.Marshaler {

				return ec.___InputValue(ctx, field.Selections, &res[idx1])
			}()
		}
		if isLen1 {
			f(idx1)
		} else {
			go f(idx1)
		}

	}
	wg.Wait()
	return arr1
}

// nolint: vetshadow
func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)

	if res == nil {
		return graphql.Null
	}

	return ec.___Type(ctx, field.Selections, res)
}

func UnmarshalCreateAnnotationInput(v interface{}) (CreateAnnotationInput, error) {
	var it CreateAnnotationInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "editable_value":
			var err error
			it.EditableValue, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "created_by":
			var err error
			it.CreatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "tag":
			var err error
			it.Tag, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "entry_id":
			var err error
			it.EntryID, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "ontology":
			var err error
			it.Ontology, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "rank":
			var err error
			var ptr1 int
			if v != nil {
				ptr1, err = graphql.UnmarshalInt(v)
				it.Rank = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateAuthorInput(v interface{}) (CreateAuthorInput, error) {
	var it CreateAuthorInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "last_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.LastName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "first_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FirstName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "initials":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Initials = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rank":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Rank = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateOrderInput(v interface{}) (CreateOrderInput, error) {
	var it CreateOrderInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "courier":
			var err error
			it.Courier, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "courer_account":
			var err error
			it.CourerAccount, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "comments":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Comments = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "payment":
			var err error
			it.Payment, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "purchase_order_num":
			var err error
			it.PurchaseOrderNum, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error
			it.Status, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "consumer":
			var err error
			it.Consumer, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "payer":
			var err error
			it.Payer, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "purchaser":
			var err error
			it.Purchaser, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "Items":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Items = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Items[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreatePermissionInput(v interface{}) (CreatePermissionInput, error) {
	var it CreatePermissionInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "permission":
			var err error
			it.Permission, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			it.Resource, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreatePlasmidInput(v interface{}) (CreatePlasmidInput, error) {
	var it CreatePlasmidInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "created_by":
			var err error
			it.CreatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "updated_by":
			var err error
			it.UpdatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Summary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "editable_summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.EditableSummary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "depositor":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Depositor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "genes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Genes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Genes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "dbxrefs":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Dbxrefs = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Dbxrefs[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "publications":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Publications = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Publications[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "plasmid_properties":
			var err error
			var ptr1 CreatePlasmidPropertiesInput
			if v != nil {
				ptr1, err = UnmarshalCreatePlasmidPropertiesInput(v)
				it.PlasmidProperties = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreatePlasmidPropertiesInput(v interface{}) (CreatePlasmidPropertiesInput, error) {
	var it CreatePlasmidPropertiesInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "image_map":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ImageMap = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "sequence":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Sequence = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreatePublicationInput(v interface{}) (CreatePublicationInput, error) {
	var it CreatePublicationInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "doi":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Doi = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "title":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Title = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "abstract":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Abstract = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "journal":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Journal = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "pub_date":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.PubDate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "volume":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Volume = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "pages":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Pages = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "issn":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Issn = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "pub_type":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.PubType = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "source":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Source = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "issue":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Issue = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "status":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Status = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "authors":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Authors = make([]*CreateAuthorInput, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 CreateAuthorInput
				if rawIf1[idx1] != nil {
					ptr2, err = UnmarshalCreateAuthorInput(rawIf1[idx1])
					it.Authors[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateRoleInput(v interface{}) (CreateRoleInput, error) {
	var it CreateRoleInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "role":
			var err error
			it.Role, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateStrainInput(v interface{}) (CreateStrainInput, error) {
	var it CreateStrainInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "created_by":
			var err error
			it.CreatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "updated_by":
			var err error
			it.UpdatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Summary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "editable_summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.EditableSummary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "depositor":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Depositor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "genes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Genes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Genes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "dbxrefs":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Dbxrefs = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Dbxrefs[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "publications":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Publications = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Publications[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "strain_properties":
			var err error
			it.StrainProperties, err = UnmarshalCreateStrainPropertiesInput(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateStrainPropertiesInput(v interface{}) (CreateStrainPropertiesInput, error) {
	var it CreateStrainPropertiesInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "systematic_name":
			var err error
			it.SystematicName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "descriptor":
			var err error
			it.Descriptor, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "species":
			var err error
			it.Species, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "plasmid":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Plasmid = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "parents":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Parents = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Parents[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "names":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Names = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Names[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalCreateUserInput(v interface{}) (CreateUserInput, error) {
	var it CreateUserInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "first_name":
			var err error
			it.FirstName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "last_name":
			var err error
			it.LastName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "organization":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Organization = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "group_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.GroupName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "first_address":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FirstAddress = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "second_address":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.SecondAddress = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "city":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.City = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "state":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.State = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "zipcode":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Zipcode = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "country":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Country = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "phone":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Phone = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "is_active":
			var err error
			it.IsActive, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateAnnotationInput(v interface{}) (UpdateAnnotationInput, error) {
	var it UpdateAnnotationInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "editable_value":
			var err error
			it.EditableValue, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "created_by":
			var err error
			it.CreatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateAuthorInput(v interface{}) (UpdateAuthorInput, error) {
	var it UpdateAuthorInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "last_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.LastName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "first_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FirstName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "initials":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Initials = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rank":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Rank = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateOrderInput(v interface{}) (UpdateOrderInput, error) {
	var it UpdateOrderInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "courier":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Courier = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "courier_account":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.CourierAccount = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "comments":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Comments = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "payment":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Payment = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "purchase_order_num":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.PurchaseOrderNum = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "status":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Status = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "Items":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Items = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Items[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdatePermissionInput(v interface{}) (UpdatePermissionInput, error) {
	var it UpdatePermissionInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "permission":
			var err error
			it.Permission, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resource":
			var err error
			it.Resource, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdatePlasmidPropertiesInput(v interface{}) (UpdatePlasmidPropertiesInput, error) {
	var it UpdatePlasmidPropertiesInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "image_map":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.ImageMap = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "sequence":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Sequence = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdatePublicationInput(v interface{}) (UpdatePublicationInput, error) {
	var it UpdatePublicationInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pub_date":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.PubDate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "volume":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Volume = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "pages":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Pages = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "pub_type":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.PubType = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "source":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Source = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "status":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Status = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "authors":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Authors = make([]*UpdateAuthorInput, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 UpdateAuthorInput
				if rawIf1[idx1] != nil {
					ptr2, err = UnmarshalUpdateAuthorInput(rawIf1[idx1])
					it.Authors[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateRoleInput(v interface{}) (UpdateRoleInput, error) {
	var it UpdateRoleInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "role":
			var err error
			it.Role, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateStockInput(v interface{}) (UpdateStockInput, error) {
	var it UpdateStockInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "updated_by":
			var err error
			it.UpdatedBy, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Summary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "editable_summary":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.EditableSummary = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "depositor":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Depositor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "genes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Genes = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Genes[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "dbxrefs":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Dbxrefs = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Dbxrefs[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "publications":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Publications = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Publications[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "strain_properties":
			var err error
			var ptr1 UpdateStrainPropertiesInput
			if v != nil {
				ptr1, err = UnmarshalUpdateStrainPropertiesInput(v)
				it.StrainProperties = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plasmid_properties":
			var err error
			var ptr1 UpdatePlasmidPropertiesInput
			if v != nil {
				ptr1, err = UnmarshalUpdatePlasmidPropertiesInput(v)
				it.PlasmidProperties = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateStrainPropertiesInput(v interface{}) (UpdateStrainPropertiesInput, error) {
	var it UpdateStrainPropertiesInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "systematic_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.SystematicName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "descriptor":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Descriptor = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "species":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Species = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plasmid":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Plasmid = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "parents":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Parents = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Parents[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		case "names":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Names = make([]*string, len(rawIf1))
			for idx1 := range rawIf1 {
				var ptr2 string
				if rawIf1[idx1] != nil {
					ptr2, err = graphql.UnmarshalString(rawIf1[idx1])
					it.Names[idx1] = &ptr2
				}
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalUpdateUserInput(v interface{}) (UpdateUserInput, error) {
	var it UpdateUserInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "first_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FirstName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "last_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.LastName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "organization":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Organization = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "group_name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.GroupName = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "first_address":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.FirstAddress = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "second_address":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.SecondAddress = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "city":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.City = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "state":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.State = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "zipcode":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Zipcode = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "country":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Country = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "phone":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Phone = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "is_active":
			var err error
			var ptr1 bool
			if v != nil {
				ptr1, err = graphql.UnmarshalBoolean(v)
				it.IsActive = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "api/annotation.graphql", Input: `type Annotation {
  id: ID!
  value: String!
  editable_value: String!
  created_by: String!
  created_at: Timestamp!
  tag: String!
  version: Int!
  entry_id: String!
  ontology: String!
  rank: Int
  is_obsolete: Boolean
}

type AnnotationListWithCursor {
  annotations: [Annotation!]!
  nextCursor: ID!
  previousCursor: ID!
  limit: Int
  totalCount: Int!
}

type DeleteItem {
  success: Boolean!
}

input CreateAnnotationInput {
  value: String!
  editable_value: String!
  created_by: String!
  tag: String!
  entry_id: String!
  ontology: String!
  rank: Int
}

input UpdateAnnotationInput {
  value: String!
  editable_value: String!
  created_by: String!
}
`},
	&ast.Source{Name: "api/mutation.graphql", Input: `type Mutation {
  # Annotation mutations
  createAnnotation(input: CreateAnnotationInput): Annotation
  updateAnnotation(id: ID!, input: UpdateAnnotationInput): Annotation
  deleteAnnotation(id: ID!): DeleteItem
  # Order mutations
  createOrder(input: CreateOrderInput): Order
  updateOrder(id: ID!, input: UpdateOrderInput): Order
  # Publication mutations
  createPublication(input: CreatePublicationInput): Publication
  updatePublication(id: ID!, input: UpdatePublicationInput): Publication
  deletePublication(id: ID!): DeleteItem
  # Stock mutations
  createStrain(input: CreateStrainInput): Stock
  createPlasmid(input: CreatePlasmidInput): Stock
  updateStock(id: ID!, input: UpdateStockInput): Stock
  deleteStock(id: ID!): DeleteItem
  # User mutations
  createUser(input: CreateUserInput): User
  updateUser(id: ID!, input: UpdateUserInput): User
  deleteUser(id: ID!): DeleteItem
  createRole(input: CreateRoleInput): Role
  updateRole(id: ID!, input: UpdateRoleInput): Role
  deleteRole(id: ID!): DeleteItem
  createPermission(input: CreatePermissionInput): Permission
  updatePermission(id: ID!, input: UpdatePermissionInput): Permission
  deletePermission(id: ID!): DeleteItem
}
`},
	&ast.Source{Name: "api/order.graphql", Input: `type Order {
  id: ID!
  created_at: Timestamp!
  updated_at: Timestamp!
  courier: String
  courer_account: String
  comments: String
  payment: String
  purchase_order_num: String
  status: String
  consumer: String
  payer: String
  purchaser: String
  Items: [String]
}

type OrderListWithCursor {
  orders: [Order!]!
  nextCursor: ID!
  previousCursor: ID!
  limit: Int
  totalCount: Int!
}

input CreateOrderInput {
  courier: String!
  courer_account: String!
  comments: String
  payment: String!
  purchase_order_num: String!
  status: String!
  consumer: String!
  payer: String!
  purchaser: String!
  Items: [String]!
}

input UpdateOrderInput {
  courier: String
  courier_account: String
  comments: String
  payment: String
  purchase_order_num: String
  status: String
  Items: [String]
}
`},
	&ast.Source{Name: "api/publication.graphql", Input: `type Publication {
  id: ID!
  doi: String
  title: String
  abstract: String
  journal: String
  pub_date: Timestamp
  volume: String
  pages: String
  issn: String
  pub_type: String
  source: String
  issue: String
  status: String
  authors: [Author]
}

type PublicationListWithCursor {
  publications: [Publication!]!
  nextCursor: ID!
  previousCursor: ID!
  limit: Int
  totalCount: Int!
}

type Author {
  last_name: String
  first_name: String
  initials: String
  rank: String
}

input CreatePublicationInput {
  doi: String
  title: String
  abstract: String
  journal: String
  pub_date: Timestamp
  volume: String
  pages: String
  issn: String
  pub_type: String
  source: String
  issue: String
  status: String
  authors: [CreateAuthorInput]
}

input CreateAuthorInput {
  last_name: String
  first_name: String
  initials: String
  rank: String
}

input UpdatePublicationInput {
  pub_date: String
  volume: String
  pages: String
  pub_type: String
  source: String
  status: String
  authors: [UpdateAuthorInput]
}

input UpdateAuthorInput {
  last_name: String
  first_name: String
  initials: String
  rank: String
}
`},
	&ast.Source{Name: "api/query.graphql", Input: `type Query {
  # Annotation queries
  annotation(id: ID!): Annotation
  annotationByEntry(
    tag: String!
    entry_id: String!
    ontology: String!
    rank: Int
    is_obsolete: Boolean
  ): Annotation
  listAnnotations(
    cursor: ID
    limit: Int
    filter: String
  ): AnnotationListWithCursor
  # Order queries
  order(id: ID!): Order
  listOrders(cursor: ID, limit: Int, filter: String): OrderListWithCursor
  # Publication queries
  publication(id: ID!): Publication
  listPublications(
    cursor: ID
    limit: Int
    filter: String
  ): PublicationListWithCursor
  # Stock queries
  stock(id: ID!): Stock
  listStocks(cursor: ID, limit: Int, filter: String): StockListWithCursor
  # User queries
  user(id: ID!): User
  userByEmail(email: String!): User
  listUsers(cursor: ID, limit: Int, filter: String): UserListWithCursor
  role(id: ID!): Role
  listRoles: [Role!]
  permission(id: ID!): Permission
  listPermissions: [Permission!]
}
`},
	&ast.Source{Name: "api/scalar.graphql", Input: `scalar Timestamp
`},
	&ast.Source{Name: "api/stock.graphql", Input: `type Stock {
  id: ID!
  created_at: Timestamp!
  updated_at: Timestamp!
  created_by: String!
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String]
  dbxrefs: [String]
  publications: [String]
  strain_properties: StrainProperties
  plasmid_properties: PlasmidProperties
}

type StrainProperties {
  systematic_name: String!
  descriptor: String!
  species: String!
  plasmid: String
  parents: [String]
  names: [String]
}

type PlasmidProperties {
  image_map: String
  sequence: String
}

type StockListWithCursor {
  stocks: [Stock!]!
  nextCursor: ID!
  previousCursor: ID!
  limit: Int
  totalCount: Int!
}

input CreateStrainInput {
  created_by: String!
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String]
  dbxrefs: [String]
  publications: [String]
  strain_properties: CreateStrainPropertiesInput!
}

input CreateStrainPropertiesInput {
  systematic_name: String!
  descriptor: String!
  species: String!
  plasmid: String
  parents: [String]
  names: [String]
}

input CreatePlasmidInput {
  created_by: String!
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String]
  dbxrefs: [String]
  publications: [String]
  plasmid_properties: CreatePlasmidPropertiesInput
}

input CreatePlasmidPropertiesInput {
  image_map: String
  sequence: String
}

input UpdateStockInput {
  updated_by: String!
  summary: String
  editable_summary: String
  depositor: String
  genes: [String]
  dbxrefs: [String]
  publications: [String]
  strain_properties: UpdateStrainPropertiesInput
  plasmid_properties: UpdatePlasmidPropertiesInput
}

input UpdateStrainPropertiesInput {
  systematic_name: String
  descriptor: String
  species: String
  plasmid: String
  parents: [String]
  names: [String]
}

input UpdatePlasmidPropertiesInput {
  image_map: String
  sequence: String
}
`},
	&ast.Source{Name: "api/user.graphql", Input: `type Permission {
  id: ID!
  permission: String!
  description: String!
  created_at: Timestamp!
  updated_at: Timestamp!
  resource: String
}

type Role {
  id: ID!
  role: String!
  description: String!
  created_at: Timestamp!
  updated_at: Timestamp!
  permissions: [Permission!]
}

type User {
  id: ID!
  first_name: String!
  last_name: String!
  email: String!
  organization: String
  group_name: String
  first_address: String
  second_address: String
  city: String
  state: String
  zipcode: String
  country: String
  phone: String
  is_active: Boolean!
  created_at: Timestamp!
  updated_at: Timestamp!
  roles: [Role!]
}

type UserListWithCursor {
  users: [User!]!
  nextCursor: ID!
  previousCursor: ID!
  limit: Int
  totalCount: Int!
}

input CreateUserInput {
  first_name: String!
  last_name: String!
  email: String!
  organization: String
  group_name: String
  first_address: String
  second_address: String
  city: String
  state: String
  zipcode: String
  country: String
  phone: String
  is_active: Boolean!
}

input UpdateUserInput {
  first_name: String
  last_name: String
  organization: String
  group_name: String
  first_address: String
  second_address: String
  city: String
  state: String
  zipcode: String
  country: String
  phone: String
  is_active: Boolean
}

input CreateRoleInput {
  role: String!
  description: String!
}

input UpdateRoleInput {
  role: String!
  description: String!
}

input CreatePermissionInput {
  permission: String!
  description: String!
  resource: String!
}

input UpdatePermissionInput {
  permission: String!
  description: String!
  resource: String!
}
`},
)
